"""
í† ë¡  ì°¸ê°€ì ì—ì´ì „íŠ¸ êµ¬í˜„

ì°¬ì„± ë˜ëŠ” ë°˜ëŒ€ ì…ì¥ìœ¼ë¡œ í† ë¡ ì— ì°¸ì—¬í•˜ëŠ” ì—ì´ì „íŠ¸
"""

import logging
import time
import os
import yaml
import json
from typing import Dict, List, Any, Optional
from datetime import datetime

from ..base.agent import Agent
from src.models.llm.llm_manager import LLMManager
from src.agents.utility.debate_emotion_inference import apply_debate_emotion_to_prompt

logger = logging.getLogger(__name__)

class DebateParticipantAgent(Agent):
    """
    í† ë¡  ì°¸ê°€ì ì—ì´ì „íŠ¸
    
    ì°¬ì„± ë˜ëŠ” ë°˜ëŒ€ ì…ì¥ì—ì„œ ì£¼ì¥ì„ í¼ì¹˜ê³  ìƒëŒ€ì˜ ì˜ê²¬ì— ëŒ€ì‘í•˜ëŠ” ì—­í•  ë‹´ë‹¹
    """
    
    def __init__(self, agent_id: str, name: str, config: Dict[str, Any]):
        """
        í† ë¡  ì°¸ê°€ì ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
        
        Args:
            agent_id: ê³ ìœ  ì‹ë³„ì
            name: ì—ì´ì „íŠ¸ ì´ë¦„
            config: ì„¤ì • ë§¤ê°œë³€ìˆ˜
        """
        super().__init__(agent_id, name, config)
        
        # ì„±ëŠ¥ ì¸¡ì •ì„ ìœ„í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡
        self.performance_timestamps = {}
        
        # ì°¸ê°€ì ì„±ê²© ë° íŠ¹ì„±
        self.role = config.get("role", "neutral")  # "pro", "con", "neutral"
        self.personality = config.get("personality", "balanced")
        self.knowledge_level = config.get("knowledge_level", "expert")
        self.style = config.get("style", "formal")
        
        # í† ë¡  ì „ëµ ë° ìŠ¤íƒ€ì¼
        self.argumentation_style = config.get("argumentation_style", "logical")  # logical, emotional, factual
        self.response_focus = config.get("response_focus", "balanced")  # attack, defend, balanced
        
        # ì² í•™ì ì •ë³´ ë™ì  ë¡œë“œ
        philosopher_key = config.get("philosopher_key", name.lower())
        self.philosopher_key = philosopher_key  # ì €ì¥
        philosopher_data = self._load_philosopher_data(philosopher_key)
        
        # ì² í•™ì ê³ ìœ  ì†ì„±ë“¤ (ë™ì  ë¡œë“œëœ ë°ì´í„° ì‚¬ìš©)
        self.philosopher_name = philosopher_data.get("name", name)
        self.philosopher_essence = philosopher_data.get("essence", "")
        self.philosopher_debate_style = philosopher_data.get("debate_style", "")
        self.philosopher_personality = philosopher_data.get("personality", "")
        self.philosopher_key_traits = philosopher_data.get("key_traits", [])
        self.philosopher_quote = philosopher_data.get("quote", "")
        
        # í† ë¡  ìƒíƒœ ë° ì´ë ¥
        self.interaction_history = []
        self.opponent_key_points = []
        self.my_key_points = []
        
        # ì…ë¡  ì¤€ë¹„ ê´€ë ¨ ì†ì„±
        self.core_arguments = []  # í•µì‹¬ ì£¼ì¥ 2-3ê°œ
        self.argument_queries = []  # ê° ì£¼ì¥ì— ëŒ€í•œ RAG ì¿¼ë¦¬ì™€ ì†ŒìŠ¤
        self.prepared_argument = ""  # ë¯¸ë¦¬ ì¤€ë¹„ëœ ì…ë¡ 
        self.argument_prepared = False  # ì…ë¡  ì¤€ë¹„ ì™„ë£Œ ì—¬ë¶€
        
        # ìƒˆë¡œìš´ ìƒíƒœ ê´€ë¦¬ í•„ë“œë“¤ (Option 2 êµ¬í˜„ìš©)
        self.is_preparing_argument = False  # í˜„ì¬ ì…ë¡  ì¤€ë¹„ ì¤‘ì¸ì§€ ì—¬ë¶€
        self.argument_preparation_task = None  # ë¹„ë™ê¸° ì¤€ë¹„ ì‘ì—… ì°¸ì¡°
        self.argument_cache_valid = False  # ìºì‹œëœ ì…ë¡ ì´ ìœ íš¨í•œì§€ ì—¬ë¶€
        self.last_preparation_context = None  # ë§ˆì§€ë§‰ ì¤€ë¹„ ì‹œ ì‚¬ìš©ëœ ì»¨í…ìŠ¤íŠ¸
        
        # ë…¼ì§€ ìŠ¤ì½”ì–´ë§ ë° ê³µê²© ì „ëµ ê´€ë ¨ ì†ì„±
        self.opponent_arguments = {}  # ìƒëŒ€ë°© ë…¼ì§€ ì €ì¥ {speaker_id: [arguments]}
        self.attack_strategies = {}  # ì¤€ë¹„ëœ ê³µê²© ì „ëµ {target_speaker_id: [strategies]}
        self.argument_scores = {}  # ë…¼ì§€ ìŠ¤ì½”ì–´ {argument_id: score_data}
        
        # ì² í•™ìë³„ ì „ëµ ê°€ì¤‘ì¹˜ ë™ì  ë¡œë“œ
        self.strategy_weights = philosopher_data.get("strategy_weights", {})
        
        # ì „ëµ ì •ë³´ ë¡œë“œ
        self.strategy_styles = self._load_strategy_styles()
        
        # LLM ê´€ë¦¬ì ì´ˆê¸°í™”
        self.llm_manager = LLMManager()

        # WebSearch ë°©ì‹
        self.web_crawling = False
    
    def _load_philosopher_data(self, philosopher_key: str) -> Dict[str, Any]:
        """
        YAML íŒŒì¼ì—ì„œ ì² í•™ì ë°ì´í„° ë¡œë“œ
        
        Args:
            philosopher_key: ì² í•™ì í‚¤ (ì˜ˆ: "socrates", "plato")
            
        Returns:
            ì² í•™ì ë°ì´í„° ë”•ì…”ë„ˆë¦¬
        """
        try:
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ philosophers/debate_optimized.yaml íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸° (src í´ë”ê°€ ìˆëŠ” ìƒìœ„ ë””ë ‰í† ë¦¬)
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:  # ë£¨íŠ¸ì— ë„ë‹¬
                    break
                project_root = parent
            
            yaml_path = os.path.join(project_root, "philosophers", "debate_optimized.yaml")
            
            if not os.path.exists(yaml_path):
                logger.warning(f"Philosopher YAML file not found at {yaml_path}")
                return self._get_default_philosopher_data(philosopher_key)
            
            with open(yaml_path, 'r', encoding='utf-8') as f:
                philosophers_data = yaml.safe_load(f)
            
            if philosopher_key in philosophers_data:
                logger.info(f"Loaded philosopher data for: {philosopher_key}")
                return philosophers_data[philosopher_key]
            else:
                logger.warning(f"Philosopher '{philosopher_key}' not found in YAML file")
                return self._get_default_philosopher_data(philosopher_key)
                
        except Exception as e:
            logger.error(f"Error loading philosopher data: {str(e)}")
            return self._get_default_philosopher_data(philosopher_key)
    
    def _load_strategy_styles(self) -> Dict[str, Any]:
        """
        JSON íŒŒì¼ì—ì„œ ì „ëµ ìŠ¤íƒ€ì¼ ì •ë³´ ë¡œë“œ
        
        Returns:
            ì „ëµ ìŠ¤íƒ€ì¼ ë”•ì…”ë„ˆë¦¬
        """
        try:
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ philosophers/debate_strategies.json íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸° (src í´ë”ê°€ ìˆëŠ” ìƒìœ„ ë””ë ‰í† ë¦¬)
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:  # ë£¨íŠ¸ì— ë„ë‹¬
                    break
                project_root = parent
            
            json_path = os.path.join(project_root, "philosophers", "debate_strategies.json")
            
            if not os.path.exists(json_path):
                logger.warning(f"Strategy JSON file not found at {json_path}")
                return self._get_default_strategy_styles()
            
            with open(json_path, 'r', encoding='utf-8') as f:
                strategies_data = json.load(f)
            
            logger.info(f"Loaded strategy styles from: {json_path}")
            return strategies_data.get("strategy_styles", {})
            
        except Exception as e:
            logger.error(f"Error loading strategy styles: {str(e)}")
            return self._get_default_strategy_styles()
    
    def _load_strategy_rag_weights(self) -> Dict[str, Any]:
        """
        YAML íŒŒì¼ì—ì„œ ì „ëµë³„ RAG ê°€ì¤‘ì¹˜ ë¡œë“œ
        
        Returns:
            ì „ëµë³„ RAG ê°€ì¤‘ì¹˜ ë”•ì…”ë„ˆë¦¬
        """
        try:
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ philosophers/strategy_rag_weights.yaml íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸° (src í´ë”ê°€ ìˆëŠ” ìƒìœ„ ë””ë ‰í† ë¦¬)
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:  # ë£¨íŠ¸ì— ë„ë‹¬
                    break
                project_root = parent
            
            yaml_path = os.path.join(project_root, "philosophers", "strategy_rag_weights.yaml")
            
            if not os.path.exists(yaml_path):
                logger.warning(f"Strategy RAG weights YAML file not found at {yaml_path}")
                return self._get_default_strategy_rag_weights()
            
            with open(yaml_path, 'r', encoding='utf-8') as f:
                rag_weights_data = yaml.safe_load(f)
            
            logger.info(f"Loaded strategy RAG weights from: {yaml_path}")
            return rag_weights_data.get("strategy_rag_weights", {})
            
        except Exception as e:
            logger.error(f"Error loading strategy RAG weights: {str(e)}")
            return self._get_default_strategy_rag_weights()
    
    def _get_default_strategy_rag_weights(self) -> Dict[str, Any]:
        """
        ê¸°ë³¸ ì „ëµë³„ RAG ê°€ì¤‘ì¹˜ ë°˜í™˜ (íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ)
        
        Returns:
            ê¸°ë³¸ ì „ëµë³„ RAG ê°€ì¤‘ì¹˜ ë”•ì…”ë„ˆë¦¬
        """
        return {
            "Clipping": {
                "data_respect": 0.5,
                "conceptual_precision": 0.2,
                "systematic_logic": 0.2,
                "pragmatic_orientation": 0.4,
                "rhetorical_independence": -0.2
            },
            "Framing Shift": {
                "data_respect": 0.2,
                "conceptual_precision": 0.5,
                "systematic_logic": 0.3,
                "pragmatic_orientation": 0.1,
                "rhetorical_independence": -0.3
            },
            "Reductive Paradox": {
                "data_respect": 0.3,
                "conceptual_precision": 0.2,
                "systematic_logic": 0.5,
                "pragmatic_orientation": 0.1,
                "rhetorical_independence": -0.3
            },
            "Conceptual Undermining": {
                "data_respect": 0.1,
                "conceptual_precision": 0.6,
                "systematic_logic": 0.3,
                "pragmatic_orientation": 0.05,
                "rhetorical_independence": -0.2
            },
            "Ethical Reversal": {
                "data_respect": 0.1,
                "conceptual_precision": 0.2,
                "systematic_logic": 0.2,
                "pragmatic_orientation": 0.5,
                "rhetorical_independence": -0.1
            },
            "Temporal Delay": {
                "data_respect": 0.5,
                "conceptual_precision": 0.2,
                "systematic_logic": 0.2,
                "pragmatic_orientation": 0.2,
                "rhetorical_independence": -0.2
            },
            "Philosophical Reframing": {
                "data_respect": 0.05,
                "conceptual_precision": 0.4,
                "systematic_logic": 0.5,
                "pragmatic_orientation": 0.05,
                "rhetorical_independence": -0.3
            }
        }
    
    def _determine_rag_usage_for_strategy(self, strategy_type: str) -> Dict[str, Any]:
        """
        íŠ¹ì • ì „ëµì— ëŒ€í•œ RAG ì‚¬ìš© ì—¬ë¶€ íŒë³„
        
        Args:
            strategy_type: ê³µê²© ì „ëµ íƒ€ì…
            
        Returns:
            RAG ì‚¬ìš© ê²°ì • ê²°ê³¼
        """
        print(f"   ğŸ§® [{self.philosopher_name}] RAG ì‚¬ìš© íŒë³„:")
        print(f"      ğŸ¯ ì „ëµ: {strategy_type}")
        
        try:
            # 1. ì „ëµë³„ RAG ê°€ì¤‘ì¹˜ ë¡œë“œ
            if not hasattr(self, 'strategy_rag_weights'):
                self.strategy_rag_weights = self._load_strategy_rag_weights()
            
            strategy_weights = self.strategy_rag_weights.get(strategy_type, {})
            if not strategy_weights:
                print(f"      âŒ ì „ëµ '{strategy_type}'ì— ëŒ€í•œ RAG ê°€ì¤‘ì¹˜ ì—†ìŒ - RAG ì‚¬ìš© ì•ˆí•¨")
                return {
                    "use_rag": False,
                    "rag_score": 0.0,
                    "threshold": 0.5,
                    "reason": "no_strategy_weights",
                    "calculation_details": {}
                }
            
            # 2. ì² í•™ì RAG ìŠ¤íƒ¯ ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            rag_stats = philosopher_data.get("rag_stats", {})
            
            if not rag_stats:
                print(f"      âŒ ì² í•™ì '{philosopher_key}'ì— ëŒ€í•œ RAG ìŠ¤íƒ¯ ì—†ìŒ - RAG ì‚¬ìš© ì•ˆí•¨")
                return {
                    "use_rag": False,
                    "rag_score": 0.0,
                    "threshold": 0.5,
                    "reason": "no_philosopher_rag_stats",
                    "calculation_details": {}
                }
            
            # 3. ë²¡í„° ë‚´ì  ê³„ì‚°: rag_score = Î£(strategy_weight[i] Ã— philosopher_rag_stat[i])
            print(f"      ğŸ“Š ì „ëµ ê°€ì¤‘ì¹˜: {strategy_weights}")
            print(f"      ğŸ­ ì² í•™ì ìŠ¤íƒ¯: {rag_stats}")
            
            rag_score = 0.0
            calculation_details = {}
            
            print(f"      ğŸ”¢ ê³„ì‚° ê³¼ì •:")
            for stat_name in ["data_respect", "conceptual_precision", "systematic_logic", "pragmatic_orientation", "rhetorical_independence"]:
                strategy_weight = strategy_weights.get(stat_name, 0.0)
                philosopher_stat = rag_stats.get(stat_name, 0.0)
                contribution = strategy_weight * philosopher_stat
                rag_score += contribution
                calculation_details[stat_name] = {
                    "strategy_weight": strategy_weight,
                    "philosopher_stat": philosopher_stat,
                    "contribution": contribution
                }
                print(f"         â€¢ {stat_name}: {strategy_weight:.3f} Ã— {philosopher_stat:.3f} = {contribution:.3f}")
            
            print(f"      ğŸ“ˆ í•©ê³„:")
            print(f"         â€¢ RAG ì ìˆ˜: {rag_score:.3f}")
            
            # 4. ì„ê³„ê°’ ë¹„êµ (0.5ë¡œ ì„¤ì •)
            threshold = 0.5
            use_rag = rag_score >= threshold
            
            print(f"         â€¢ ì„ê³„ê°’: {threshold}")
            print(f"         â€¢ ê²°ì •: {'RAG ì‚¬ìš©' if use_rag else 'RAG ì‚¬ìš© ì•ˆí•¨'} ({rag_score:.3f} {'â‰¥' if use_rag else '<'} {threshold})")
            print()
            
            return {
                "use_rag": use_rag,
                "rag_score": rag_score,
                "threshold": threshold,
                "reason": "calculated" if use_rag else "below_threshold",
                "calculation_details": calculation_details
            }
            
        except Exception as e:
            logger.error(f"Error determining RAG usage for strategy '{strategy_type}': {str(e)}")
            print(f"      âŒ RAG íŒë³„ ì˜¤ë¥˜: {str(e)} - RAG ì‚¬ìš© ì•ˆí•¨")
            return {
                "use_rag": False,
                "rag_score": 0.0,
                "threshold": 0.5,
                "reason": "error",
                "error": str(e),
                "calculation_details": {}
            }
    
    def _get_default_philosopher_data(self, philosopher_key: str) -> Dict[str, Any]:
        """
        ê¸°ë³¸ ì² í•™ì ë°ì´í„° ë°˜í™˜ (íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ)
        
        Args:
            philosopher_key: ì² í•™ì í‚¤
            
        Returns:
            ê¸°ë³¸ ì² í•™ì ë°ì´í„°
        """
        return {
            "name": philosopher_key.capitalize(),
            "essence": "A thoughtful philosopher who engages in meaningful debate",
            "debate_style": "Presents logical arguments with clear reasoning",
            "personality": "Analytical and respectful in discourse",
            "key_traits": ["logical reasoning", "clear communication"],
            "quote": "The pursuit of truth through dialogue",
            "strategy_weights": {
                "Clipping": 0.2,
                "Framing Shift": 0.2,
                "Reductive Paradox": 0.15,
                "Conceptual Undermining": 0.15,
                "Ethical Reversal": 0.15,
                "Temporal Delay": 0.1,
                "Philosophical Reframing": 0.05
            }
        }
    
    def _get_default_strategy_styles(self) -> Dict[str, Any]:
        """
        ê¸°ë³¸ ì „ëµ ìŠ¤íƒ€ì¼ ë°˜í™˜ (íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ)
        
        Returns:
            ê¸°ë³¸ ì „ëµ ìŠ¤íƒ€ì¼ ë”•ì…”ë„ˆë¦¬
        """
        return {
            "Clipping": {
                "description": "Refute a specific claim directly",
                "style_prompt": "'X' is wrong because...",
                "example": "Direct refutation with evidence"
            },
            "Framing Shift": {
                "description": "Challenge assumptions and reframe the discussion",
                "style_prompt": "You're assuming Y, but what if we asked Z instead?",
                "example": "Shift perspective to deeper questions"
            },
            "Reductive Paradox": {
                "description": "Extend logic to expose flaws",
                "style_prompt": "If we follow your logic to the end, then...",
                "example": "Show extreme consequences"
            },
            "Conceptual Undermining": {
                "description": "Question key definitions and concepts",
                "style_prompt": "What do we even mean by 'X' here?",
                "example": "Challenge conceptual clarity"
            },
            "Ethical Reversal": {
                "description": "Turn positive claims into ethical concerns",
                "style_prompt": "You call it progress, but isn't it dehumanization?",
                "example": "Reveal ethical implications"
            },
            "Temporal Delay": {
                "description": "Raise long-term consequence concerns",
                "style_prompt": "Even if it works now, what happens in 20 years?",
                "example": "Focus on future implications"
            },
            "Philosophical Reframing": {
                "description": "Replace with more fundamental questions",
                "style_prompt": "Maybe the real question is not what X is, but what it means to us.",
                "example": "Shift to existential questions"
            }
        }
    
    @classmethod
    def create_from_philosopher_key(cls, agent_id: str, philosopher_key: str, role: str, config: Dict[str, Any] = None) -> 'DebateParticipantAgent':
        """
        ì² í•™ì í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—ì´ì „íŠ¸ ìƒì„±
        
        Args:
            agent_id: ì—ì´ì „íŠ¸ ID
            philosopher_key: ì² í•™ì í‚¤ (ì˜ˆ: "socrates", "plato")
            role: í† ë¡  ì—­í•  ("pro", "con")
            config: ì¶”ê°€ ì„¤ì •
            
        Returns:
            ìƒì„±ëœ DebateParticipantAgent ì¸ìŠ¤í„´ìŠ¤
        """
        if config is None:
            config = {}
        
        # ì² í•™ì í‚¤ì™€ ì—­í•  ì„¤ì •
        config["philosopher_key"] = philosopher_key
        config["role"] = role
        
        # ì—ì´ì „íŠ¸ ìƒì„±
        agent = cls(agent_id, philosopher_key, config)
        
        logger.info(f"Created philosopher agent: {agent.philosopher_name} ({philosopher_key}) as {role}")
        return agent
    
    def process(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        ì—ì´ì „íŠ¸ë¡œ ìš”ì²­ ì²˜ë¦¬
        
        Args:
            input_data: ì²˜ë¦¬í•  ì…ë ¥ ë°ì´í„°
            
        Returns:
            ì²˜ë¦¬ ê²°ê³¼
        """
        action = input_data.get("action", "")
        
        # ì„±ëŠ¥ ì¸¡ì • ì‹œì‘
        start_time = time.time()
        action_key = f"{self.agent_id}_{action}"
        
        # ë¡œê·¸ ë©”ì‹œì§€ ê°œì„  - analyze_opponent_argumentsì˜ ê²½ìš° ëŒ€ìƒ ë°œì–¸ì í‘œì‹œ
        if action == "analyze_opponent_arguments":
            target_speaker = input_data.get("speaker_id", "unknown")
            print(f"ğŸ• [{self.philosopher_name}] â†’ {target_speaker} ë…¼ì§€ ë¶„ì„ ì‹œì‘: {time.strftime('%H:%M:%S', time.localtime(start_time))}")
        else:
            print(f"ğŸ• [{self.philosopher_name}] {action} ì‹œì‘: {time.strftime('%H:%M:%S', time.localtime(start_time))}")
        
        try:
            result = None
            
            if action == "prepare_argument":
                result = self._prepare_argument(input_data)
            elif action == "generate_response":
                result = self._generate_response(input_data)
            elif action == "analyze_opponent_arguments":
                result = self.analyze_and_score_arguments(
                    input_data.get("opponent_response", ""),
                    input_data.get("speaker_id", "unknown")
                )
            elif action == "prepare_attack_strategies":
                result = self.prepare_attack_strategies_for_speaker(
                    input_data.get("target_speaker_id", "unknown")
                )
            elif action == "get_best_attack_strategy":
                result = self.get_best_attack_strategy(
                    input_data.get("target_speaker_id", "unknown"),
                    input_data.get("context", {})
                )
            else:
                result = {"status": "error", "message": f"Unknown action: {action}"}
            
            # ì„±ëŠ¥ ì¸¡ì • ì¢…ë£Œ
            end_time = time.time()
            duration = end_time - start_time
            self.performance_timestamps[action_key] = {
                "start": start_time,
                "end": end_time,
                "duration": duration
            }
            
            # ì™„ë£Œ ë¡œê·¸ ë©”ì‹œì§€ë„ ê°œì„ 
            if action == "analyze_opponent_arguments":
                target_speaker = input_data.get("speaker_id", "unknown")
                print(f"âœ… [{self.philosopher_name}] â†’ {target_speaker} ë…¼ì§€ ë¶„ì„ ì™„ë£Œ: {time.strftime('%H:%M:%S', time.localtime(end_time))} (ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ)")
            else:
                print(f"âœ… [{self.philosopher_name}] {action} ì™„ë£Œ: {time.strftime('%H:%M:%S', time.localtime(end_time))} (ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ)")
            
            return result
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            
            # ì‹¤íŒ¨ ë¡œê·¸ ë©”ì‹œì§€ë„ ê°œì„ 
            if action == "analyze_opponent_arguments":
                target_speaker = input_data.get("speaker_id", "unknown")
                print(f"âŒ [{self.philosopher_name}] â†’ {target_speaker} ë…¼ì§€ ë¶„ì„ ì‹¤íŒ¨: {time.strftime('%H:%M:%S', time.localtime(end_time))} (ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ) - {str(e)}")
            else:
                print(f"âŒ [{self.philosopher_name}] {action} ì‹¤íŒ¨: {time.strftime('%H:%M:%S', time.localtime(end_time))} (ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ) - {str(e)}")
            
            logger.error(f"Error in {action}: {str(e)}")
            return {"status": "error", "message": f"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"}
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """ì„±ëŠ¥ ì¸¡ì • ê²°ê³¼ ìš”ì•½ ë°˜í™˜"""
        summary = {
            "agent_id": self.agent_id,
            "philosopher_name": self.philosopher_name,
            "total_actions": len(self.performance_timestamps),
            "actions": {}
        }
        
        total_time = 0
        for action_key, timing in self.performance_timestamps.items():
            action_name = action_key.replace(f"{self.agent_id}_", "")
            summary["actions"][action_name] = {
                "duration": timing["duration"],
                "start_time": time.strftime('%H:%M:%S', time.localtime(timing["start"])),
                "end_time": time.strftime('%H:%M:%S', time.localtime(timing["end"]))
            }
            total_time += timing["duration"]
        
        summary["total_time"] = total_time
        return summary
    
    def update_state(self, state_update: Dict[str, Any]) -> None:
        """
        ì—ì´ì „íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸
        
        Args:
            state_update: ìƒíƒœ ì—…ë°ì´íŠ¸ ë°ì´í„°
        """
        for key, value in state_update.items():
            self.state[key] = value
            
        # í•„ìš”í•œ ê²½ìš° LLM ê´€ë¦¬ì ì—…ë°ì´íŠ¸
        if "llm_manager" in state_update:
            self.llm_manager = state_update.get("llm_manager")
    
    def set_llm_manager(self, llm_manager: Any) -> None:
        """
        LLM ê´€ë¦¬ì ì„¤ì •
        
        Args:
            llm_manager: LLM ê´€ë¦¬ì ì¸ìŠ¤í„´ìŠ¤
        """
        self.llm_manager = llm_manager
    
    def _generate_response(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        ì‘ë‹µ ìƒì„± ì²˜ë¦¬
        
        Args:
            input_data: ì‘ë‹µ ìƒì„±ì— í•„ìš”í•œ ë°ì´í„°
            
        Returns:
            ìƒì„±ëœ ì‘ë‹µ
        """
        context = input_data.get("context", {})
        dialogue_state = input_data.get("dialogue_state", {})
        stance_statements = input_data.get("stance_statements", {})
        
        # dialogue_stateë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì— ì €ì¥í•˜ì—¬ ë‹¤ë¥¸ ë©”ì„œë“œì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•¨
        self._current_dialogue_state = dialogue_state
        
        response = self._generate_response_internal(context, dialogue_state, stance_statements)
        return {"status": "success", "message": response}
    
    def _generate_response_internal(self, context: Dict[str, Any], dialogue_state: Dict[str, Any], stance_statements: Dict[str, str]) -> str:
        """
        í† ë¡  ì‘ë‹µ ìƒì„±
        
        Args:
            context: ì‘ë‹µ ìƒì„± ì»¨í…ìŠ¤íŠ¸
            dialogue_state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
            stance_statements: ì°¬ë°˜ ì…ì¥ ì§„ìˆ ë¬¸
            
        Returns:
            ìƒì„±ëœ ì‘ë‹µ í…ìŠ¤íŠ¸
        """
        # ğŸ¯ dialogue_stateë¥¼ ì €ì¥í•˜ì—¬ ë‹¤ë¥¸ ë©”ì„œë“œë“¤ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•¨
        self._current_dialogue_state = dialogue_state
        
        current_stage = context.get("current_stage", "")
        topic = context.get("topic", "")
        recent_messages = context.get("recent_messages", [])
        emotion_enhancement = context.get("emotion_enhancement", {})
        
        # ìƒí˜¸ë…¼ì¦ ë‹¨ê³„ì—ì„œëŠ” ì§§ê³  ì§ì ‘ì ì¸ ê³µê²©/ì§ˆë¬¸ í˜•íƒœë¡œ ìƒì„±
        if current_stage == "interactive_argument":
            return self._generate_interactive_argument_response(
                topic, recent_messages, dialogue_state, stance_statements, emotion_enhancement
            )
        
        # ê¸°ì¡´ ë¡œì§ ìœ ì§€ (ì…ë¡ , ê²°ë¡  ë“±)
        # ... existing code ...
    
    def _generate_interactive_argument_response(self, topic: str, recent_messages: List[Dict[str, Any]], dialogue_state: Dict[str, Any], stance_statements: Dict[str, str], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        ìƒí˜¸ë…¼ì¦ ë‹¨ê³„ì—ì„œ ì‘ë‹µ ìƒì„± - ëŒ€í™” ê´€ë¦¬ìì˜ ë‹¨ê³„ ê´€ë¦¬ì— ì˜ì¡´
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            dialogue_state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
            stance_statements: ì°¬ë°˜ ì…ì¥ ì§„ìˆ ë¬¸
            emotion_enhancement: ê°ì • ê°•í™” ë°ì´í„° (ì„ íƒì )
            
        Returns:
            ìƒì„±ëœ ì‘ë‹µ í…ìŠ¤íŠ¸
        """
        # ëŒ€í™” ê´€ë¦¬ìê°€ ì´ë¯¸ ìƒí™©ì„ íŒë‹¨í–ˆìœ¼ë¯€ë¡œ ë‹¨ìˆœíˆ ì‘ë‹µ ìƒì„±
        # ìµœê·¼ ìƒí™©ì— ë”°ë¼ ê³µê²©/ë°©ì–´/íŒ”ë¡œìš°ì—… ê²°ì •
        
        # ìµœê·¼ ë©”ì‹œì§€ ë¶„ì„ìœ¼ë¡œ í˜„ì¬ ìƒí™© ê°„ë‹¨ íŒë‹¨
        situation = self._simple_situation_analysis(recent_messages)
        
        if situation == "defending":
            return self._generate_defense_response(topic, recent_messages, dialogue_state, stance_statements, emotion_enhancement)
        elif situation == "following_up":
            return self._generate_followup_response(topic, recent_messages, dialogue_state, stance_statements, emotion_enhancement)
        else:  # attacking (ê¸°ë³¸ê°’)
            return self._generate_attack_response(topic, recent_messages, dialogue_state, stance_statements, emotion_enhancement)
    
    def _simple_situation_analysis(self, recent_messages: List[Dict[str, Any]]) -> str:
        """
        ê°„ë‹¨í•œ ìƒí™© ë¶„ì„ - ëŒ€í™” ê´€ë¦¬ìì˜ ë‹¨ê³„ ê´€ë¦¬ë¥¼ ë³´ì™„
        
        Args:
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            
        Returns:
            ìƒí™© ("attacking", "defending", "following_up")
        """
        if len(recent_messages) < 1:
            return "attacking"
        
        # ë§ˆì§€ë§‰ ë©”ì‹œì§€ ë¶„ì„
        last_message = recent_messages[-1]
        last_speaker = last_message.get('speaker_id', '')
        my_agent_id = getattr(self, 'agent_id', self.name.lower())
        
        # ìƒëŒ€ë°©ì´ ë§ˆì§€ë§‰ì— ë°œì–¸í–ˆê³ , ê·¸ ì „ì— ë‚´ê°€ ë°œì–¸í–ˆìœ¼ë©´ íŒ”ë¡œìš°ì—…
        if len(recent_messages) >= 2:
            second_last_message = recent_messages[-2]
            second_last_speaker = second_last_message.get('speaker_id', '')
            
            # ìƒëŒ€ë°©ì´ ë§ˆì§€ë§‰ ë°œì–¸, ë‚´ê°€ ê·¸ ì „ ë°œì–¸ â†’ íŒ”ë¡œìš°ì—…
            if (last_speaker != my_agent_id and 
                second_last_speaker == my_agent_id):
                return "following_up"
        
        # ìƒëŒ€ë°©ì´ ë§ˆì§€ë§‰ì— ë°œì–¸í–ˆìœ¼ë©´ ë°©ì–´
        if last_speaker != my_agent_id and last_speaker != "moderator":
            return "defending"
        
        # ê¸°ë³¸ì ìœ¼ë¡œ ê³µê²©
        return "attacking"
    
    def _is_defending_against_attack(self, recent_messages: List[Dict[str, Any]]) -> bool:
        """
        ìµœê·¼ ë©”ì‹œì§€ì—ì„œ ìƒëŒ€ë°©ì´ ë‚˜ë¥¼ ê³µê²©í–ˆëŠ”ì§€ í™•ì¸
        
        Args:
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            
        Returns:
            ë°©ì–´ ìƒí™© ì—¬ë¶€
        """
        if not recent_messages:
            return False
        
        # ê°€ì¥ ìµœê·¼ ë©”ì‹œì§€ê°€ ìƒëŒ€ë°©ì˜ ê³µê²©ì¸ì§€ í™•ì¸
        last_message = recent_messages[-1]
        last_speaker = last_message.get('speaker_id', '')
        last_role = last_message.get('role', '')
        
        # ë‚´ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ì°¸ê°€ìì˜ ë°œì–¸ì´ê³ , ëª¨ë”ë ˆì´í„°ê°€ ì•„ë‹ˆë©´ ê³µê²©ìœ¼ë¡œ ê°„ì£¼
        opposite_role = "con" if self.role == "pro" else "pro"
        
        return (last_role == opposite_role and 
                last_speaker != "moderator" and 
                last_speaker != self.agent_id)
    
    def _generate_defense_response(self, topic: str, recent_messages: List[Dict[str, Any]], dialogue_state: Dict[str, Any], stance_statements: Dict[str, str], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        ë°©ì–´ ì‘ë‹µ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            dialogue_state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
            stance_statements: ì°¬ë°˜ ì…ì¥ ì§„ìˆ ë¬¸
            emotion_enhancement: ê°ì • ê°•í™” ë°ì´í„° (ì„ íƒì )
            
        Returns:
            ìƒì„±ëœ ë°©ì–´ ì‘ë‹µ
        """
        print(f"ğŸ›¡ï¸ [{self.philosopher_name}] ë°©ì–´ ì‘ë‹µ ìƒì„± ì‹œì‘")
        
        # 1. ìƒëŒ€ë°© ê³µê²© ë¶„ì„
        attack_info = self._analyze_incoming_attack(recent_messages)
        
        # 2. ë°©ì–´ ì „ëµ ì„ íƒ
        defense_strategy = self._select_defense_strategy(attack_info, emotion_enhancement)
        
        # 3. ë°©ì–´ìš© RAG ì‚¬ìš© ì—¬ë¶€ ê²°ì •
        defense_rag_decision = self._determine_defense_rag_usage(defense_strategy, attack_info)
        
        # 4. ë°©ì–´ ì‘ë‹µ ìƒì„±
        defense_response = self._generate_defense_response_with_strategy(
            topic, recent_messages, stance_statements, defense_strategy, 
            defense_rag_decision, emotion_enhancement
        )
        
        # ğŸ¯ ë°©ì–´ ì „ëµ ì •ë³´ ì €ì¥ (íŒ”ë¡œìš°ì—…ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡)
        defense_strategy_info = {
            'strategy_type': defense_strategy,
            'rag_decision': defense_rag_decision,
            'attack_info': attack_info,
            'timestamp': time.time(),
            'target_attacker': attack_info.get('attacker_id', 'unknown')
        }
        
        # ë°©ì–´ ì „ëµì„ ì—ì´ì „íŠ¸ ì†ì„±ì— ì €ì¥
        self.last_defense_strategy = defense_strategy_info
        
        # ë°©ì–´ ê¸°ë¡ë„ ì €ì¥ (ì—¬ëŸ¬ ë°©ì–´ ì „ëµ íˆìŠ¤í† ë¦¬)
        if not hasattr(self, 'defense_history'):
            self.defense_history = []
        self.defense_history.append(defense_strategy_info)
        
        # ìµœëŒ€ 5ê°œê¹Œì§€ë§Œ ìœ ì§€
        if len(self.defense_history) > 5:
            self.defense_history = self.defense_history[-5:]
        
        print(f"ğŸ›¡ï¸ [{self.philosopher_name}] ë°©ì–´ ì‘ë‹µ ìƒì„± ì™„ë£Œ - ì „ëµ: {defense_strategy} ì €ì¥ë¨")
        return defense_response
    
    def _generate_attack_response(self, topic: str, recent_messages: List[Dict[str, Any]], dialogue_state: Dict[str, Any], stance_statements: Dict[str, str], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        ê³µê²© ì‘ë‹µ ìƒì„± (ê¸°ì¡´ ë¡œì§)
        """
        # ìƒëŒ€ë°© ì—ì´ì „íŠ¸ ì •ë³´ ì°¾ê¸° (ê°œì„ ëœ ë¡œì§)
        opposite_role = "con" if self.role == "pro" else "pro"
        target_agent_name = None
        target_agent_id = None
        
        # 1. ìµœê·¼ ë©”ì‹œì§€ì—ì„œ ìƒëŒ€ë°© ì—ì´ì „íŠ¸ ì°¾ê¸° (ëª¨ë”ë ˆì´í„° ì œì™¸)
        for msg in reversed(recent_messages):
            msg_role = msg.get('role', '')
            msg_speaker_id = msg.get('speaker_id', '')
            
            # ì˜¤ì§ ìƒëŒ€í¸ ì—­í• ì˜ ì°¸ê°€ìë§Œ ì°¾ê¸° (ëª¨ë”ë ˆì´í„° ì œì™¸)
            if msg_role == opposite_role and msg_speaker_id and msg_speaker_id != "moderator":
                target_agent_id = msg_speaker_id
                break
        
        # 2. target_agent_idê°€ ì—†ìœ¼ë©´ dialogue_stateì—ì„œ ì°¾ê¸°
        if not target_agent_id:
            # dialogue_stateì˜ êµ¬ì¡° í™•ì¸ì„ ìœ„í•œ ë””ë²„ê¹…
            print(f"   ğŸ” ë””ë²„ê¹…: dialogue_state í‚¤ë“¤: {list(dialogue_state.keys())}")
            
            # ì—¬ëŸ¬ ê°€ëŠ¥í•œ ê²½ë¡œì—ì„œ ì°¸ê°€ì ì •ë³´ ì°¾ê¸°
            participants = None
            
            # ê²½ë¡œ 1: dialogue_state['participants']
            if 'participants' in dialogue_state:
                participants = dialogue_state['participants']
                print(f"   ğŸ” ë””ë²„ê¹…: participants êµ¬ì¡°: {participants}")
            
            # ê²½ë¡œ 2: dialogue_stateì—ì„œ ì§ì ‘ pro/con ì°¾ê¸°
            elif opposite_role in dialogue_state:
                participants = {opposite_role: dialogue_state[opposite_role]}
                print(f"   ğŸ” ë””ë²„ê¹…: ì§ì ‘ ì°¾ì€ {opposite_role}: {participants}")
            
            if participants:
                opposite_participants = participants.get(opposite_role, [])
                print(f"   ğŸ” ë””ë²„ê¹…: {opposite_role} ì°¸ê°€ìë“¤: {opposite_participants}")
                
                if opposite_participants:
                    # ì²« ë²ˆì§¸ ìƒëŒ€ë°© ì„ íƒ
                    if isinstance(opposite_participants, list) and len(opposite_participants) > 0:
                        target_agent_id = opposite_participants[0]
                    elif isinstance(opposite_participants, str):
                        target_agent_id = opposite_participants
                    
                    print(f"   ğŸ” ë””ë²„ê¹…: ì„ íƒëœ target_agent_id: {target_agent_id}")
        
        # 3. ì—¬ì „íˆ ì—†ìœ¼ë©´ ì‹¤ì œ ì°¸ê°€ìì—ì„œ ìƒëŒ€ë°© ì°¾ê¸°
        if not target_agent_id:
            # ì‹¤ì œ ì°¸ê°€ì ëª©ë¡ì—ì„œ ìƒëŒ€ë°© ì°¾ê¸°
            try:
                # dialogue_stateì—ì„œ ëª¨ë“  ì°¸ê°€ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                all_participants = []
                
                # speaking_historyì—ì„œ ì‹¤ì œ ì°¸ê°€ìë“¤ ì¶”ì¶œ
                speaking_history = dialogue_state.get('speaking_history', [])
                if speaking_history:
                    for msg in speaking_history:
                        speaker_id = msg.get('speaker_id', '')
                        role = msg.get('role', '')
                        if speaker_id and role in ['pro', 'con'] and speaker_id != self.agent_id:
                            if role == opposite_role and speaker_id not in all_participants:
                                all_participants.append(speaker_id)
                
                # ìƒëŒ€ë°© ì—­í• ì˜ ì²« ë²ˆì§¸ ì°¸ê°€ì ì„ íƒ
                if all_participants:
                    target_agent_id = all_participants[0]
                    print(f"   ğŸ” ë””ë²„ê¹…: speaking_historyì—ì„œ ì°¾ì€ ìƒëŒ€ë°©: {target_agent_id}")
                else:
                    # fallback: ê¸°ë³¸ ìƒëŒ€ë°© ì„¤ì •
                    if self.role == "pro":
                        target_agent_id = "con_participant"  # ì°¬ì„±ì¸¡ì˜ ìƒëŒ€ë°©
                    elif self.role == "con":
                        target_agent_id = "pro_participant"  # ë°˜ëŒ€ì¸¡ì˜ ìƒëŒ€ë°©
                    else:
                        target_agent_id = "opponent"
                    
                    print(f"   ğŸ” ë””ë²„ê¹…: ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •ëœ target_agent_id: {target_agent_id}")
                    
            except Exception as e:
                print(f"   âŒ ìƒëŒ€ë°© ì°¾ê¸° ì˜¤ë¥˜: {str(e)}")
                target_agent_id = "opponent"
        
        # 4. ì² í•™ì ì´ë¦„ ì°¾ê¸° (ê°œì„ ëœ ë¡œì§)
        target_agent_name = self._get_philosopher_name(target_agent_id)
        
        # ìµœê·¼ ë©”ì‹œì§€ í…ìŠ¤íŠ¸ í˜•ì‹í™”
        recent_messages_text = "\n".join([
            f"{msg.get('role', 'Unknown')} ({msg.get('speaker_id', '')}): {msg.get('text', '')}" 
            for msg in recent_messages[-3:]  # ìµœê·¼ 3ê°œë§Œ
        ])
        
        # ë‚´ ì…ì¥ê³¼ ë°˜ëŒ€ ì…ì¥ í™•ì¸
        my_stance = stance_statements.get(self.role) if self.role in ["pro", "con"] else ""
        opposite_stance = stance_statements.get(opposite_role, "")
        
        # ê³µê²© ì „ëµ ê°€ì ¸ì˜¤ê¸° (ì¤€ë¹„ëœ ê²ƒì´ ìˆìœ¼ë©´)
        attack_strategy = None
        target_argument_info = None
        
        if target_agent_id and hasattr(self, 'attack_strategies') and target_agent_id in self.attack_strategies:
            strategies = self.attack_strategies[target_agent_id]
            if strategies:
                attack_strategy = strategies[0]  # ì²« ë²ˆì§¸ ì „ëµ ì‚¬ìš©
                target_argument_info = attack_strategy.get('target_argument', {})
                
                # ğŸ¯ ìƒí˜¸ë…¼ì¦ ì „ëµ ì •ë³´ ì¶œë ¥
                strategy_type = attack_strategy.get('strategy_type', 'Unknown')
                target_claim = target_argument_info.get('claim', 'Unknown claim')[:100] + "..." if len(target_argument_info.get('claim', '')) > 100 else target_argument_info.get('claim', 'Unknown claim')
                vulnerability_score = attack_strategy.get('vulnerability_score', 0.0)
                
                print(f"ğŸ¯ [{self.philosopher_name}] ìƒí˜¸ë…¼ì¦ ì „ëµ:")
                print(f"   ğŸ“ ê³µê²© ëŒ€ìƒ: {target_agent_name}")
                print(f"   ğŸ—¡ï¸  ì‚¬ìš© ì „ëµ: {strategy_type}")
                print(f"   ğŸ¯ ëŒ€ìƒ ë…¼ì§€: {target_claim}")
                print(f"   âš¡ ì·¨ì•½ì„± ì ìˆ˜: {vulnerability_score:.2f}")
                
                # ì „ëµ ì„¸ë¶€ ì •ë³´ë„ ì¶œë ¥
                attack_plan = attack_strategy.get('attack_plan', {})
                if attack_plan:
                    target_point = attack_plan.get('target_point', '')
                    key_phrase = attack_plan.get('key_phrase', '')
                    if target_point:
                        print(f"   ğŸ” ê³µê²© í¬ì¸íŠ¸: {target_point[:80]}...")
                    if key_phrase:
                        print(f"   ğŸ’¬ í•µì‹¬ ê³µê²©êµ¬: {key_phrase[:60]}...")
        else:
            print(f"ğŸ¯ [{self.philosopher_name}] ìƒí˜¸ë…¼ì¦ ì „ëµ:")
            print(f"   ğŸ“ ê³µê²© ëŒ€ìƒ: {target_agent_name}")
            print(f"   ğŸ—¡ï¸  ì‚¬ìš© ì „ëµ: ì¼ë°˜ì  ë°˜ë°• (ì¤€ë¹„ëœ ì „ëµ ì—†ìŒ)")
            print(f"   ğŸ¯ ëŒ€ìƒ ë…¼ì§€: ìµœê·¼ ë°œì–¸ ì „ì²´")
            print(f"   ğŸ’¡ ìƒëŒ€ë°© ID: {target_agent_id} (ë””ë²„ê¹…ìš©)")
        
        # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„± - ìƒí˜¸ë…¼ì¦ì— íŠ¹í™”
        system_prompt = f"""
You are {self.philosopher_name}, a philosopher with this essence: {self.philosopher_essence}
Your debate style: {self.philosopher_debate_style}
Your personality: {self.philosopher_personality}

This is the INTERACTIVE ARGUMENT phase of the debate. Your responses should be:
1. SHORT and DIRECT (2-3 sentences maximum)
2. AGGRESSIVE and CHALLENGING
3. Focus on ATTACKING specific points made by your opponent
4. Ask POINTED QUESTIONS that expose weaknesses
5. Use your philosophical approach to challenge their logic

CRITICAL: Write your ENTIRE response in the SAME LANGUAGE as the debate topic. 
If the topic is in Korean, respond in Korean. If in English, respond in English.

You are directly confronting {target_agent_name}. Address them by name and attack their specific arguments.
"""

        # ìœ ì € í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        user_prompt = f"""
DEBATE TOPIC: "{topic}"

YOUR POSITION: {my_stance}
OPPONENT'S POSITION: {opposite_stance}

TARGET OPPONENT: {target_agent_name}

RECENT EXCHANGE:
{recent_messages_text}

TASK: Generate a SHORT, DIRECT response (2-3 sentences max) that:
1. Directly addresses {target_agent_name} by name
2. Attacks a specific point they made
3. Asks a challenging question OR points out a logical flaw
4. Uses your philosophical style to challenge them

IMPORTANT: Write your response in the SAME LANGUAGE as the debate topic "{topic}".
If the topic contains Korean text, write in Korean. If in English, write in English.

"""

        # ê³µê²© ì „ëµì´ ìˆìœ¼ë©´ ì¶”ê°€
        if attack_strategy:
            strategy_type = attack_strategy.get('strategy_type', '')
            strategy_description = attack_strategy.get('attack_plan', {}).get('strategy_application', '')
            key_phrases = [attack_strategy.get('attack_plan', {}).get('key_phrase', '')]
            
            user_prompt += f"""
ATTACK STRATEGY: Use the "{strategy_type}" approach
Strategy Description: {strategy_description}
Key Phrases to Consider: {', '.join(key_phrases[:3])}
"""
            
            # RAG ê²°ê³¼ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            rag_decision = attack_strategy.get('rag_decision', {})
            if rag_decision.get('use_rag') and rag_decision.get('results'):
                rag_formatted = self._format_attack_rag_results(rag_decision['results'], strategy_type)
                if rag_formatted:
                    user_prompt += f"""
{rag_formatted}
INSTRUCTION: Incorporate this evidence naturally into your {strategy_type} attack.
"""
                    print(f"   ğŸ“š [{self.philosopher_name}] RAG ì •ë³´ í”„ë¡¬í”„íŠ¸ì— í¬í•¨ë¨")
                else:
                    print(f"   ğŸ“š [{self.philosopher_name}] RAG ê²°ê³¼ í¬ë§·íŒ… ì‹¤íŒ¨")
            else:
                print(f"   ğŸ“š [{self.philosopher_name}] RAG ì‚¬ìš© ì•ˆí•¨ ë˜ëŠ” ê²°ê³¼ ì—†ìŒ")

        user_prompt += f"""
Remember: Be CONCISE, DIRECT, and CONFRONTATIONAL. This is rapid-fire debate, not a long speech.
Address {target_agent_name} directly and challenge their specific arguments.
Write in the SAME LANGUAGE as the topic "{topic}".

Your response:"""

        # ê°ì • ê°•í™” ì ìš© (ì„ íƒì )
        if emotion_enhancement:
            from ...agents.utility.debate_emotion_inference import apply_debate_emotion_to_prompt
            system_prompt, user_prompt = apply_debate_emotion_to_prompt(system_prompt, user_prompt, emotion_enhancement)
        
        try:
            # LLM í˜¸ì¶œ - ì§§ì€ ì‘ë‹µì„ ìœ„í•´ max_tokens ì œí•œ
            response = self.llm_manager.generate_response(
                    system_prompt=system_prompt,
                    user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=10000  
            )
            
            if response:
                return response.strip()
            else:
                return f"{target_agent_name}ë‹˜, ê·¸ ë…¼ë¦¬ì—ëŠ” ëª…ë°±í•œ í—ˆì ì´ ìˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ ì„¤ëª…í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"
                
        except Exception as e:
            logger.error(f"Error generating interactive argument response: {str(e)}")
            return f"{target_agent_name}ë‹˜, ê·¸ ì£¼ì¥ì— ëŒ€í•´ ë” êµ¬ì²´ì ì¸ ê·¼ê±°ë¥¼ ì œì‹œí•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."
    
    def _analyze_incoming_attack(self, recent_messages: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        ë“¤ì–´ì˜¤ëŠ” ê³µê²© ë¶„ì„ - ê³µê²©ì ì—ì´ì „íŠ¸ì˜ ì‹¤ì œ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            
        Returns:
            ê³µê²© ì •ë³´ ë¶„ì„ ê²°ê³¼
        """
        if not recent_messages:
            return {"attack_strategy": "Unknown", "rag_used": False, "attacker_id": "unknown"}
        
        last_message = recent_messages[-1]
        attacker_id = last_message.get('speaker_id', 'unknown')
        attack_text = last_message.get('text', '')
        
        print(f"   ğŸ” [{self.philosopher_name}] ê³µê²© ì •ë³´ ë¶„ì„:")
        print(f"      ğŸ‘¤ ê³µê²©ì: {attacker_id}")
        
        # ê³µê²©ì ì—ì´ì „íŠ¸ì˜ ì‹¤ì œ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        attack_info = self._get_attacker_strategy_info(attacker_id)
        
        if attack_info["attack_strategy"] != "Unknown":
            print(f"      âœ… ì‹¤ì œ ê³µê²© ì „ëµ ë°œê²¬: {attack_info['attack_strategy']}")
            print(f"      ğŸ“š ê³µê²© RAG ì‚¬ìš©: {attack_info['rag_used']}")
        else:
            print(f"      âŒ ê³µê²© ì „ëµ ì •ë³´ ì—†ìŒ - í‚¤ì›Œë“œ ì¶”ì • ì‚¬ìš©")
            # Fallback: í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì • (ê¸°ì¡´ ë¡œì§)
            attack_info = self._estimate_attack_strategy_from_keywords(attack_text, attacker_id)
        
        attack_info["attacker_id"] = attacker_id
        attack_info["attack_text"] = attack_text[:200]  # ë¶„ì„ìš© ì¼ë¶€ í…ìŠ¤íŠ¸
        
        return attack_info
    
    def _get_attacker_strategy_info(self, attacker_id: str) -> Dict[str, Any]:
        """
        ê³µê²©ì ì—ì´ì „íŠ¸ì˜ ì‹¤ì œ ì‚¬ìš©í•œ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            attacker_id: ê³µê²©ì ì—ì´ì „íŠ¸ ID
            
        Returns:
            ê³µê²© ì „ëµ ì •ë³´
        """
        try:
            # 1. í† ë¡  ë§¤ë‹ˆì €ë‚˜ ê¸€ë¡œë²Œ ìƒíƒœì—ì„œ ê³µê²©ì ì—ì´ì „íŠ¸ ì°¸ì¡° ê°€ì ¸ì˜¤ê¸°
            attacker_agent = self._get_attacker_agent_reference(attacker_id)
            
            if attacker_agent is None:
                print(f"         âŒ ê³µê²©ì ì—ì´ì „íŠ¸ ì°¸ì¡° ì—†ìŒ")
                return {"attack_strategy": "Unknown", "rag_used": False}
            
            # 2. ê³µê²©ìì˜ ìµœê·¼ ì‚¬ìš©í•œ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            recent_attack_strategy = self._get_recent_attack_strategy(attacker_agent, attacker_id)
            
            if recent_attack_strategy:
                strategy_type = recent_attack_strategy.get('strategy_type', 'Unknown')
                rag_decision = recent_attack_strategy.get('rag_decision', {})
                rag_used = rag_decision.get('use_rag', False)
                
                print(f"         âœ… ê³µê²©ì ì „ëµ ì •ë³´:")
                print(f"            ğŸ—¡ï¸ ì „ëµ: {strategy_type}")
                print(f"            ğŸ“š RAG: {rag_used}")
                print(f"            âš¡ ì·¨ì•½ì„± ì ìˆ˜: {recent_attack_strategy.get('vulnerability_score', 0.0):.2f}")
                
                return {
                    "attack_strategy": strategy_type,
                    "rag_used": rag_used,
                    "vulnerability_score": recent_attack_strategy.get('vulnerability_score', 0.0),
                    "attack_plan": recent_attack_strategy.get('attack_plan', {}),
                    "source": "actual_attacker_data"
                }
            else:
                print(f"         âŒ ê³µê²©ìì˜ ìµœê·¼ ì „ëµ ì •ë³´ ì—†ìŒ")
                return {"attack_strategy": "Unknown", "rag_used": False}
                
        except Exception as e:
            logger.error(f"Error getting attacker strategy info: {str(e)}")
            print(f"         âŒ ê³µê²©ì ì „ëµ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
            return {"attack_strategy": "Unknown", "rag_used": False}
    
    def _get_attacker_agent_reference(self, attacker_id: str):
        """
        ê³µê²©ì ì—ì´ì „íŠ¸ ì°¸ì¡° ê°€ì ¸ì˜¤ê¸°
        
        Args:
            attacker_id: ê³µê²©ì ID
            
        Returns:
            ê³µê²©ì ì—ì´ì „íŠ¸ ê°ì²´ ë˜ëŠ” None
        """
        try:
            # ë°©ë²• 1: dialogue_stateì—ì„œ agents ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ìµœìš°ì„ )
            if hasattr(self, '_current_dialogue_state') and self._current_dialogue_state:
                agents = self._current_dialogue_state.get('agents', {})
                if attacker_id in agents:
                    return agents[attacker_id]
            
            # ë°©ë²• 2: í† ë¡  ëŒ€í™” ë§¤ë‹ˆì €ì—ì„œ ì°¸ê°€ì ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ê°€ì¥ ì¼ë°˜ì )
            if hasattr(self, '_debate_dialogue_manager'):
                participants = getattr(self._debate_dialogue_manager, 'participants', {})
                if attacker_id in participants:
                    return participants[attacker_id]
            
            # ë°©ë²• 3: ê¸€ë¡œë²Œ ì—ì´ì „íŠ¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ê°€ì ¸ì˜¤ê¸° (ë§Œì•½ ìˆë‹¤ë©´)
            if hasattr(self, '_agent_registry'):
                registry = getattr(self._agent_registry, 'agents', {})
                if attacker_id in registry:
                    return registry[attacker_id]
            
            # ë°©ë²• 4: ë¶€ëª¨ ê°ì²´ë‚˜ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ê°€ì ¸ì˜¤ê¸°
            if hasattr(self, '_context') and self._context:
                context_participants = self._context.get('participants', {})
                if attacker_id in context_participants:
                    return context_participants[attacker_id]
            
            # ë°©ë²• 5: í´ë˜ìŠ¤ ë ˆë²¨ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (ë§Œì•½ êµ¬í˜„ë˜ì–´ ìˆë‹¤ë©´)
            if hasattr(self.__class__, '_agent_instances'):
                instances = getattr(self.__class__, '_agent_instances', {})
                if attacker_id in instances:
                    return instances[attacker_id]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting attacker agent reference: {str(e)}")
            return None
    
    def _get_recent_attack_strategy(self, attacker_agent, target_speaker_id: str) -> Dict[str, Any]:
        """
        ê³µê²©ì ì—ì´ì „íŠ¸ì˜ ìµœê·¼ ì‚¬ìš©í•œ ê³µê²© ì „ëµ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            attacker_agent: ê³µê²©ì ì—ì´ì „íŠ¸ ê°ì²´
            target_speaker_id: ê³µê²© ëŒ€ìƒ (ë‚˜ ìì‹ )
            
        Returns:
            ìµœê·¼ ê³µê²© ì „ëµ ì •ë³´
        """
        try:
            # ê³µê²©ìì˜ attack_strategiesì—ì„œ ë‚˜ì— ëŒ€í•œ ì „ëµ ê°€ì ¸ì˜¤ê¸°
            if hasattr(attacker_agent, 'attack_strategies'):
                attack_strategies = getattr(attacker_agent, 'attack_strategies', {})
                
                # ë‚˜(target_speaker_id)ì— ëŒ€í•œ ê³µê²© ì „ëµë“¤
                my_id = getattr(self, 'agent_id', self.name.lower())
                if my_id in attack_strategies:
                    strategies = attack_strategies[my_id]
                    if strategies and len(strategies) > 0:
                        # ê°€ì¥ ìµœê·¼ ì‚¬ìš©í•œ ì „ëµ (ì²« ë²ˆì§¸ ë˜ëŠ” ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„)
                        return strategies[0]
            
            # ìµœê·¼ ì‚¬ìš©í•œ ì „ëµ ê¸°ë¡ì´ ìˆëŠ”ì§€ í™•ì¸ (ë§Œì•½ ë³„ë„ë¡œ ì €ì¥í•œë‹¤ë©´)
            if hasattr(attacker_agent, 'last_used_strategy'):
                last_strategy = getattr(attacker_agent, 'last_used_strategy', None)
                if last_strategy:
                    return last_strategy
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting recent attack strategy: {str(e)}")
            return None
    
    def _estimate_attack_strategy_from_keywords(self, attack_text: str, attacker_id: str) -> Dict[str, Any]:
        """
        í‚¤ì›Œë“œ ê¸°ë°˜ ê³µê²© ì „ëµ ì¶”ì • (Fallback ë°©ë²•)
        
        Args:
            attack_text: ê³µê²© í…ìŠ¤íŠ¸
            attacker_id: ê³µê²©ì ID
            
        Returns:
            ì¶”ì •ëœ ê³µê²© ì •ë³´
        """
        attack_text_lower = attack_text.lower()
        
        print(f"         ğŸ”„ í‚¤ì›Œë“œ ê¸°ë°˜ ì „ëµ ì¶”ì • ì‹œì‘")
        
        # ê³µê²© ì „ëµ ì¶”ì • (í‚¤ì›Œë“œ ê¸°ë°˜)
        attack_strategy = "Unknown"
        if any(word in attack_text_lower for word in ['wrong', 'incorrect', 'false', 'error']):
            attack_strategy = "Clipping"
        elif any(word in attack_text_lower for word in ['assume', 'framework', 'perspective']):
            attack_strategy = "FramingShift"
        elif any(word in attack_text_lower for word in ['extreme', 'consequence', 'lead to']):
            attack_strategy = "ReductiveParadox"
        elif any(word in attack_text_lower for word in ['define', 'mean', 'concept']):
            attack_strategy = "ConceptualUndermining"
        elif any(word in attack_text_lower for word in ['ethical', 'moral', 'wrong']):
            attack_strategy = "EthicalReversal"
        elif any(word in attack_text_lower for word in ['future', 'long-term', 'eventually']):
            attack_strategy = "TemporalDelay"
        elif any(word in attack_text_lower for word in ['fundamental', 'real question', 'deeper']):
            attack_strategy = "PhilosophicalReframing"
        
        # RAG ì‚¬ìš© ì—¬ë¶€ ì¶”ì • (êµ¬ì²´ì  ë°ì´í„°/ì¸ìš© ìˆìœ¼ë©´ RAG ì‚¬ìš©ìœ¼ë¡œ ì¶”ì •)
        rag_used = any(indicator in attack_text_lower for indicator in [
            'study', 'research', 'data', 'statistics', 'according to', 'evidence', 'findings'
        ])
        
        print(f"         ğŸ“Š ì¶”ì • ê²°ê³¼: {attack_strategy} (RAG: {rag_used})")
        
        return {
            "attack_strategy": attack_strategy,
            "rag_used": rag_used,
            "source": "keyword_estimation"
        }
    
    def _select_defense_strategy(self, attack_info: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        ë°©ì–´ ì „ëµ ì„ íƒ
        
        Args:
            attack_info: ê³µê²© ì •ë³´
            emotion_enhancement: ê°ì • ê°•í™” ì •ë³´
            
        Returns:
            ì„ íƒëœ ë°©ì–´ ì „ëµëª…
        """
        print(f"   ğŸ›¡ï¸ [{self.philosopher_name}] ë°©ì–´ ì „ëµ ì„ íƒ ì‹œì‘")
        
        try:
            # 1. defense_map.yamlì—ì„œ í›„ë³´ ì „ëµ ê°€ì ¸ì˜¤ê¸°
            defense_candidates = self._get_defense_candidates_from_map(attack_info, emotion_enhancement)
            
            if not defense_candidates:
                print(f"   âŒ ë°©ì–´ í›„ë³´ ì „ëµ ì—†ìŒ - ê¸°ë³¸ Clarify ì‚¬ìš©")
                return "Clarify"
            
            print(f"   ğŸ“‹ í›„ë³´ ì „ëµë“¤: {defense_candidates}")
            
            # 2. ì² í•™ìì˜ defense_weights ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            defense_weights = philosopher_data.get("defense_weights", {})
            
            if not defense_weights:
                print(f"   âŒ ì² í•™ì ë°©ì–´ ê°€ì¤‘ì¹˜ ì—†ìŒ - ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©")
                return defense_candidates[0]
            
            print(f"   âš–ï¸ ì² í•™ì ë°©ì–´ ê°€ì¤‘ì¹˜: {defense_weights}")
            
            # 3. í›„ë³´ ì „ëµë“¤ì— ëŒ€í•œ ê°€ì¤‘ì¹˜ë§Œ ì¶”ì¶œí•˜ê³  ì •ê·œí™”
            candidate_weights = {}
            total_weight = 0.0
            
            for strategy in defense_candidates:
                weight = defense_weights.get(strategy, 0.1)  # ê¸°ë³¸ê°’ 0.1
                candidate_weights[strategy] = weight
                total_weight += weight
            
            if total_weight == 0:
                print(f"   âŒ ì´ ê°€ì¤‘ì¹˜ê°€ 0 - ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©")
                return defense_candidates[0]
            
            # ì •ê·œí™”
            normalized_weights = {k: v/total_weight for k, v in candidate_weights.items()}
            print(f"   ğŸ“Š ì •ê·œí™”ëœ ê°€ì¤‘ì¹˜: {normalized_weights}")
            
            # 4. í™•ë¥ ì  ì„ íƒ
            import random
            rand_val = random.random()
            cumulative = 0.0
            
            for strategy, prob in normalized_weights.items():
                cumulative += prob
                if rand_val <= cumulative:
                    print(f"   âœ… ì„ íƒëœ ë°©ì–´ ì „ëµ: {strategy} (í™•ë¥ : {prob:.3f})")
                    return strategy
            
            # í˜¹ì‹œë‚˜ í•˜ëŠ” fallback
            selected = defense_candidates[0]
            print(f"   ğŸ”„ Fallback ë°©ì–´ ì „ëµ: {selected}")
            return selected
            
        except Exception as e:
            logger.error(f"Error selecting defense strategy: {str(e)}")
            print(f"   âŒ ë°©ì–´ ì „ëµ ì„ íƒ ì˜¤ë¥˜: {str(e)} - ê¸°ë³¸ Clarify ì‚¬ìš©")
            return "Clarify"
    
    def _get_defense_candidates_from_map(self, attack_info: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> List[str]:
        """
        defense_map.yamlì—ì„œ ë°©ì–´ í›„ë³´ ì „ëµë“¤ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            attack_info: ê³µê²© ì •ë³´
            emotion_enhancement: ê°ì • ì •ë³´
            
        Returns:
            ë°©ì–´ í›„ë³´ ì „ëµ ëª©ë¡
        """
        try:
            # defense_map.yaml ë¡œë“œ
            import yaml
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            yaml_path = os.path.join(project_root, "philosophers", "defense_map.yaml")
            
            if not os.path.exists(yaml_path):
                print(f"   âŒ defense_map.yaml ì—†ìŒ: {yaml_path}")
                return ["Clarify", "Accept"]  # ê¸°ë³¸ê°’
            
            with open(yaml_path, 'r', encoding='utf-8') as f:
                defense_map = yaml.safe_load(f)
            
            # ê³µê²© ì „ëµê³¼ RAG ì‚¬ìš© ì—¬ë¶€
            attack_strategy = attack_info.get("attack_strategy", "Unknown")
            rag_used = attack_info.get("rag_used", False)
            
            # ê°ì • ìƒíƒœ (ì—†ìœ¼ë©´ neutral)
            emotion_state = "neutral"
            if emotion_enhancement:
                emotion_state = emotion_enhancement.get("emotion_type", "neutral")
            
            rag_key = "RAG_YES" if rag_used else "RAG_NO"
            
            print(f"   ğŸ” ë°©ì–´ ë§µ ì¡°íšŒ: {attack_strategy} -> {rag_key} -> {emotion_state}")
            
            # defense_mapì—ì„œ í›„ë³´ ì°¾ê¸°
            if attack_strategy in defense_map:
                strategy_map = defense_map[attack_strategy]
                if rag_key in strategy_map:
                    emotion_map = strategy_map[rag_key]
                    if emotion_state in emotion_map:
                        candidates = emotion_map[emotion_state]
                        print(f"   âœ… í›„ë³´ ì „ëµ ë°œê²¬: {candidates}")
                        return candidates if isinstance(candidates, list) else [candidates]
                    else:
                        print(f"   âŒ ê°ì • ìƒíƒœ '{emotion_state}' ëª» ì°¾ìŒ in {list(emotion_map.keys())}")
                else:
                    print(f"   âŒ RAG í‚¤ '{rag_key}' ëª» ì°¾ìŒ in {list(strategy_map.keys())}")
            else:
                print(f"   âŒ ê³µê²© ì „ëµ '{attack_strategy}' ëª» ì°¾ìŒ in {list(defense_map.keys())}")
            
            # ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ê°’
            print(f"   âŒ ë°©ì–´ ë§µì—ì„œ í›„ë³´ ëª» ì°¾ìŒ - ê¸°ë³¸ê°’ ì‚¬ìš©")
            return ["Clarify", "Accept"]
            
        except Exception as e:
            logger.error(f"Error getting defense candidates: {str(e)}")
            print(f"   âŒ ë°©ì–´ í›„ë³´ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
            return ["Clarify", "Accept"]
    
    def _determine_defense_rag_usage(self, defense_strategy: str, attack_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        ë°©ì–´ìš© RAG ì‚¬ìš© ì—¬ë¶€ ê²°ì •
        
        Args:
            defense_strategy: ì„ íƒëœ ë°©ì–´ ì „ëµ
            attack_info: ê³µê²© ì •ë³´
            
        Returns:
            RAG ì‚¬ìš© ê²°ì • ê²°ê³¼
        """
        print(f"   ğŸ“š [{self.philosopher_name}] ë°©ì–´ RAG ì‚¬ìš© ì—¬ë¶€ íŒë³„:")
        print(f"      ğŸ›¡ï¸ ë°©ì–´ ì „ëµ: {defense_strategy}")
        
        try:
            # 1. defense_strategies.jsonì—ì„œ rag_weight ê°€ì ¸ì˜¤ê¸°
            defense_rag_weight = self._get_defense_strategy_rag_weight(defense_strategy)
            
            # 2. ì² í•™ìì˜ rag_affinity ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            rag_affinity = philosopher_data.get("rag_affinity", 0.5)
            
            # 3. ê³µê²©ì˜ RAG ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¥¸ ê°€ì¤‘ì¹˜
            attack_rag_weight = 1.0 if attack_info.get("rag_used", False) else 0.3
            
            # 4. ì„¸ ê°’ì˜ ê³±
            rag_score = defense_rag_weight * rag_affinity * attack_rag_weight
            
            # 5. ì„ê³„ê°’ ë¹„êµ (0.3ìœ¼ë¡œ ì„¤ì •)
            threshold = 0.3
            use_rag = rag_score >= threshold
            
            print(f"      ğŸ“Š ê³„ì‚°:")
            print(f"         â€¢ ë°©ì–´ ì „ëµ ê°€ì¤‘ì¹˜: {defense_rag_weight}")
            print(f"         â€¢ ì² í•™ì ì¹œí™”ë„: {rag_affinity}")
            print(f"         â€¢ ê³µê²© RAG ê°€ì¤‘ì¹˜: {attack_rag_weight}")
            print(f"         â€¢ RAG ì ìˆ˜: {defense_rag_weight} Ã— {rag_affinity} Ã— {attack_rag_weight} = {rag_score:.3f}")
            print(f"         â€¢ ì„ê³„ê°’: {threshold}")
            print(f"         â€¢ ê²°ì •: {'RAG ì‚¬ìš©' if use_rag else 'RAG ì‚¬ìš© ì•ˆí•¨'}")
            
            return {
                "use_rag": use_rag,
                "rag_score": rag_score,
                "threshold": threshold,
                "defense_rag_weight": defense_rag_weight,
                "rag_affinity": rag_affinity,
                "attack_rag_weight": attack_rag_weight
            }
            
        except Exception as e:
            logger.error(f"Error determining defense RAG usage: {str(e)}")
            print(f"      âŒ ë°©ì–´ RAG íŒë³„ ì˜¤ë¥˜: {str(e)} - RAG ì‚¬ìš© ì•ˆí•¨")
            return {
                "use_rag": False,
                "rag_score": 0.0,
                "threshold": 0.3,
                "error": str(e)
            }
    
    def _get_defense_strategy_rag_weight(self, defense_strategy: str) -> float:
        """
        defense_strategies.jsonì—ì„œ íŠ¹ì • ë°©ì–´ ì „ëµì˜ rag_weight ê°€ì ¸ì˜¤ê¸°
        
        Args:
            defense_strategy: ë°©ì–´ ì „ëµëª…
            
        Returns:
            RAG ê°€ì¤‘ì¹˜
        """
        try:
            import json
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            json_path = os.path.join(project_root, "philosophers", "defense_strategies.json")
            
            if not os.path.exists(json_path):
                print(f"         âŒ defense_strategies.json ì—†ìŒ - ê¸°ë³¸ê°’ 0.4 ì‚¬ìš©")
                return 0.4
            
            with open(json_path, 'r', encoding='utf-8') as f:
                defense_data = json.load(f)
            
            defense_styles = defense_data.get("defense_styles", {})
            strategy_info = defense_styles.get(defense_strategy, {})
            rag_weight = strategy_info.get("rag_weight", 0.4)
            
            print(f"         âœ… {defense_strategy} RAG ê°€ì¤‘ì¹˜: {rag_weight}")
            return rag_weight
            
        except Exception as e:
            logger.error(f"Error getting defense strategy rag weight: {str(e)}")
            print(f"         âŒ ë°©ì–´ ì „ëµ ê°€ì¤‘ì¹˜ ì¡°íšŒ ì˜¤ë¥˜: {str(e)} - ê¸°ë³¸ê°’ 0.4 ì‚¬ìš©")
            return 0.4
    
    def _generate_defense_response_with_strategy(self, topic: str, recent_messages: List[Dict[str, Any]], stance_statements: Dict[str, str], defense_strategy: str, defense_rag_decision: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        ë°©ì–´ ì „ëµê³¼ RAG ì—¬ë¶€ì— ë”°ë¼ ë°©ì–´ ì‘ë‹µ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            recent_messages: ìµœê·¼ ë©”ì‹œì§€
            stance_statements: ì…ì¥ ì§„ìˆ ë¬¸
            defense_strategy: ì„ íƒëœ ë°©ì–´ ì „ëµ
            defense_rag_decision: RAG ì‚¬ìš© ê²°ì •
            emotion_enhancement: ê°ì • ê°•í™”
            
        Returns:
            ìƒì„±ëœ ë°©ì–´ ì‘ë‹µ
        """
        print(f"   ğŸ’¬ [{self.philosopher_name}] ë°©ì–´ ì‘ë‹µ ìƒì„±:")
        print(f"      ğŸ›¡ï¸ ì „ëµ: {defense_strategy}")
        print(f"      ğŸ“š RAG ì‚¬ìš©: {defense_rag_decision.get('use_rag', False)}")
        
        try:
            # ë°©ì–´ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            defense_info = self._get_defense_strategy_info(defense_strategy)
            
            # ìƒëŒ€ë°© ì •ë³´
            attacker_name = self._get_philosopher_name(recent_messages[-1].get('speaker_id', 'unknown'))
            attack_text = recent_messages[-1].get('text', '') if recent_messages else ''
            
            # ë‚´ ì…ì¥
            my_stance = stance_statements.get(self.role, "")
            
            # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
            system_prompt = f"""
You are {self.philosopher_name}, a philosopher with this essence: {self.philosopher_essence}
Your debate style: {self.philosopher_debate_style}
Your personality: {self.philosopher_personality}

You are responding defensively using the "{defense_strategy}" strategy.
Strategy description: {defense_info.get('description', '')}
Strategy purpose: {defense_info.get('purpose', '')}
Style prompt: {defense_info.get('style_prompt', '')}

Your response should be:
1. SHORT and DIRECT (2-3 sentences maximum)
2. Use the {defense_strategy} approach
3. Address {attacker_name} directly
4. Maintain your philosophical character

CRITICAL: Write your ENTIRE response in the SAME LANGUAGE as the debate topic.
If the topic is in Korean, respond in Korean. If in English, respond in English.
"""

            # ìœ ì € í”„ë¡¬í”„íŠ¸
            user_prompt = f"""
DEBATE TOPIC: "{topic}"
YOUR POSITION: {my_stance}

{attacker_name} just attacked you with: "{attack_text}"

DEFENSE STRATEGY: {defense_strategy}
- Description: {defense_info.get('description', '')}
- Style: {defense_info.get('style_prompt', '')}
- Example approach: {defense_info.get('example', '')}

TASK: Generate a SHORT defensive response (2-3 sentences max) that:
1. Uses the {defense_strategy} approach
2. Addresses {attacker_name} directly by name
3. Responds to their specific attack
4. Maintains your philosophical perspective

IMPORTANT: Write your response in the SAME LANGUAGE as the debate topic "{topic}".
If the topic contains Korean text, write in Korean. If in English, write in English.

"""

            # RAG ì‚¬ìš©í•˜ëŠ” ê²½ìš° ê²€ìƒ‰ ìˆ˜í–‰
            if defense_rag_decision.get('use_rag', False):
                defense_rag_results = self._perform_defense_rag_search(attack_text, defense_strategy)
                if defense_rag_results:
                    rag_formatted = self._format_defense_rag_results(defense_rag_results, defense_strategy)
                    user_prompt += f"""
{rag_formatted}
INSTRUCTION: Incorporate this supporting information naturally into your {defense_strategy} response.
"""
                    print(f"      ğŸ“š RAG ì •ë³´ ì¶”ê°€ë¨ ({len(defense_rag_results)}ê°œ ê²°ê³¼)")

            user_prompt += f"""
Remember: Be CONCISE, DIRECT, and use the {defense_strategy} approach. 
Address {attacker_name} directly and defend effectively.
Write in the SAME LANGUAGE as the topic "{topic}".

Your {defense_strategy} response:"""

            # ê°ì • ê°•í™” ì ìš©
            if emotion_enhancement:
                from ...agents.utility.debate_emotion_inference import apply_debate_emotion_to_prompt
                system_prompt, user_prompt = apply_debate_emotion_to_prompt(system_prompt, user_prompt, emotion_enhancement)

            # LLM í˜¸ì¶œ
            response = self.llm_manager.generate_response(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=1000
            )
            
            if response:
                print(f"      âœ… ë°©ì–´ ì‘ë‹µ ìƒì„± ì™„ë£Œ")
                return response.strip()
            else:
                fallback = f"{attacker_name}ë‹˜, {defense_info.get('style_prompt', 'Let me clarify')}: ì œ ì…ì¥ì€ ì—¬ì „íˆ ìœ íš¨í•©ë‹ˆë‹¤."
                print(f"      ğŸ”„ Fallback ì‘ë‹µ ì‚¬ìš©")
                return fallback
                
        except Exception as e:
            logger.error(f"Error generating defense response: {str(e)}")
            print(f"      âŒ ë°©ì–´ ì‘ë‹µ ìƒì„± ì˜¤ë¥˜: {str(e)}")
            fallback = f"ì œ ì…ì¥ì— ëŒ€í•´ ëª…í™•íˆ ì„¤ëª…ë“œë¦¬ê² ìŠµë‹ˆë‹¤."
            return fallback
    
    def _get_defense_strategy_info(self, defense_strategy: str) -> Dict[str, Any]:
        """
        defense_strategies.jsonì—ì„œ ë°©ì–´ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            defense_strategy: ë°©ì–´ ì „ëµëª…
            
        Returns:
            ë°©ì–´ ì „ëµ ì •ë³´
        """
        try:
            import json
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            json_path = os.path.join(project_root, "philosophers", "defense_strategies.json")
            
            if os.path.exists(json_path):
                with open(json_path, 'r', encoding='utf-8') as f:
                    defense_data = json.load(f)
                
                defense_styles = defense_data.get("defense_styles", {})
                return defense_styles.get(defense_strategy, {})
            
            # ê¸°ë³¸ê°’
            return {
                "description": f"Use {defense_strategy} approach",
                "purpose": "Defend position",
                "style_prompt": "Let me respond...",
                "example": f"Example of {defense_strategy}"
            }
            
        except Exception as e:
            logger.error(f"Error getting defense strategy info: {str(e)}")
            return {
                "description": f"Use {defense_strategy} approach",
                "purpose": "Defend position", 
                "style_prompt": "Let me respond...",
                "example": f"Example of {defense_strategy}"
            }
    
    def _perform_defense_rag_search(self, attack_text: str, defense_strategy: str) -> List[Dict[str, Any]]:
        """
        ë°©ì–´ìš© RAG ê²€ìƒ‰ ìˆ˜í–‰
        
        Args:
            attack_text: ìƒëŒ€ë°© ê³µê²© í…ìŠ¤íŠ¸
            defense_strategy: ë°©ì–´ ì „ëµ
            
        Returns:
            ê²€ìƒ‰ ê²°ê³¼
        """
        try:
            # ë°©ì–´ìš© ì¿¼ë¦¬ ìƒì„± (ê°„ë‹¨í™”)
            defense_query = self._generate_defense_rag_query(attack_text, defense_strategy)
            
            # ê²€ìƒ‰ ìˆ˜í–‰ (ê¸°ì¡´ ë©”ì„œë“œ ì¬ì‚¬ìš©)
            search_results = self._web_search(defense_query)
            
            print(f"      ğŸ” ë°©ì–´ RAG ì¿¼ë¦¬: '{defense_query}'")
            print(f"      ğŸ“Š ê²€ìƒ‰ ê²°ê³¼: {len(search_results)}ê°œ")
            
            return search_results[:2]  # ë°©ì–´ëŠ” 2ê°œë§Œ ì‚¬ìš©
            
        except Exception as e:
            logger.error(f"Error in defense RAG search: {str(e)}")
            return []
    
    def _generate_defense_rag_query(self, attack_text: str, defense_strategy: str) -> str:
        """
        ë°©ì–´ìš© RAG ì¿¼ë¦¬ ìƒì„±
        
        Args:
            attack_text: ê³µê²© í…ìŠ¤íŠ¸
            defense_strategy: ë°©ì–´ ì „ëµ
            
        Returns:
            ê²€ìƒ‰ ì¿¼ë¦¬
        """
        # ê³µê²© í…ìŠ¤íŠ¸ì—ì„œ í•µì‹¬ í‚¤ì›Œë“œ ì¶”ì¶œ
        keywords = self._extract_key_concept(attack_text)
        
        # ë°©ì–´ ì „ëµë³„ ì ‘ë‘ì‚¬
        strategy_prefixes = {
            "Refute": "evidence supporting",
            "Clarify": "clarification examples",
            "Accept": "balanced perspective",
            "Reframe": "alternative framework",
            "Counter-Challenge": "counter evidence",
            "Synthesis": "comprehensive analysis"
        }
        
        prefix = strategy_prefixes.get(defense_strategy, "information about")
        return f"{prefix} {keywords}"
    
    def _format_defense_rag_results(self, rag_results: List[Dict[str, Any]], defense_strategy: str) -> str:
        """
        ë°©ì–´ìš© RAG ê²°ê³¼ í¬ë§·íŒ…
        
        Args:
            rag_results: RAG ê²€ìƒ‰ ê²°ê³¼
            defense_strategy: ë°©ì–´ ì „ëµ
            
        Returns:
            í¬ë§·íŒ…ëœ RAG ì •ë³´
        """
        if not rag_results:
            return ""
        
        strategy_headers = {
            "Refute": "SUPPORTING EVIDENCE",
            "Clarify": "CLARIFICATION SOURCES",
            "Accept": "BALANCED PERSPECTIVES", 
            "Reframe": "ALTERNATIVE VIEWS",
            "Counter-Challenge": "COUNTER-EVIDENCE",
            "Synthesis": "COMPREHENSIVE ANALYSIS"
        }
        
        header = strategy_headers.get(defense_strategy, "SUPPORTING INFORMATION")
        
        formatted = f"\n{header} (use strategically):\n"
        
        for i, result in enumerate(rag_results, 1):
            title = result.get('title', 'Source')
            content = result.get('content', result.get('snippet', ''))
            formatted += f"{i}. {title}: {content}\n"
        
        return formatted
    
    def _get_philosopher_name(self, agent_id: str) -> str:
        """
        ì—ì´ì „íŠ¸ IDë¡œë¶€í„° ì² í•™ì ì´ë¦„ ì°¾ê¸°
        
        Args:
            agent_id: ì—ì´ì „íŠ¸ ID
            
        Returns:
            ì² í•™ì ì´ë¦„
        """
        try:
            import yaml
            import os
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ philosophers/debate_optimized.yaml íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸° (src í´ë”ê°€ ìˆëŠ” ìƒìœ„ ë””ë ‰í† ë¦¬)
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:  # ë£¨íŠ¸ì— ë„ë‹¬
                    break
                project_root = parent
            
            yaml_path = os.path.join(project_root, "philosophers", "debate_optimized.yaml")
            
            if os.path.exists(yaml_path):
                with open(yaml_path, 'r', encoding='utf-8') as file:
                    philosophers = yaml.safe_load(file)
                
                if agent_id in philosophers:
                    return philosophers[agent_id].get("name", agent_id)
            
            # YAMLì—ì„œ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ ë§¤í•‘
            name_mapping = {
                "nietzsche": "ë‹ˆì²´",
                "camus": "ì¹´ë®ˆ", 
                "hegel": "í—¤ê²”",
                "socrates": "ì†Œí¬ë¼í…ŒìŠ¤",
                "plato": "í”Œë¼í†¤",
                "aristotle": "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤"
            }
            
            return name_mapping.get(agent_id.lower(), agent_id.capitalize())
            
        except Exception as e:
            logger.warning(f"Error getting philosopher name for {agent_id}: {str(e)}")
            # ê¸°ë³¸ ë§¤í•‘ìœ¼ë¡œ fallback
            name_mapping = {
                "nietzsche": "ë‹ˆì²´",
                "camus": "ì¹´ë®ˆ", 
                "hegel": "í—¤ê²”",
                "socrates": "ì†Œí¬ë¼í…ŒìŠ¤",
                "plato": "í”Œë¼í†¤",
                "aristotle": "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤"
            }
            return name_mapping.get(agent_id.lower(), agent_id.capitalize())
    
    def prepare_argument_with_rag(self, topic: str, stance_statement: str, context: Dict[str, Any] = None) -> None:
        """
        RAGë¥¼ í™œìš©í•œ ì…ë¡  ì¤€ë¹„ (í•µì‹¬ ì£¼ì¥ ìƒì„± â†’ ì¿¼ë¦¬ ìƒì„± â†’ RAG ê²€ìƒ‰ â†’ ì£¼ì¥ ê°•í™” â†’ ìµœì¢… ì…ë¡  ìƒì„±)
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            stance_statement: ì…ì¥ ì§„ìˆ ë¬¸
            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
        """
        try:
            logger.info(f"[{self.agent_id}] Starting argument preparation with RAG")
            
            # 1ë‹¨ê³„: í•µì‹¬ ì£¼ì¥ 2-3ê°œ ìƒì„±
            self._generate_core_arguments(topic, stance_statement)
            
            # 2ë‹¨ê³„: ê° ì£¼ì¥ì— ëŒ€í•œ RAG ì¿¼ë¦¬ì™€ ì†ŒìŠ¤ ìƒì„±
            self._generate_rag_queries_for_arguments(topic)
            
            # 3ë‹¨ê³„: RAG ê²€ìƒ‰ ìˆ˜í–‰ ë° ì£¼ì¥ ê°•í™”
            self._strengthen_arguments_with_rag()
            
            # 4ë‹¨ê³„: ìµœì¢… ì…ë¡  ìƒì„±
            self._generate_final_opening_argument(topic, stance_statement)
            
            self.argument_prepared = True
            logger.info(f"[{self.agent_id}] Argument preparation completed successfully")
            
        except Exception as e:
            logger.error(f"[{self.agent_id}] Error in argument preparation: {str(e)}")
            self.argument_prepared = False
    
    def _generate_core_arguments(self, topic: str, stance_statement: str) -> None:
        """
        í•µì‹¬ ì£¼ì¥ 2-3ê°œ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            stance_statement: ì…ì¥ ì§„ìˆ ë¬¸
        """
        system_prompt = f"""
You are a skilled debater preparing core arguments for your position.
Your role is {self.role.upper()} and your stance is: "{stance_statement}"

Generate 2-3 core arguments that strongly support your position.
Each argument should be:
1. Clear and specific
2. Logically sound
3. Potentially strengthened with evidence/examples
4. Distinct from other arguments
"""

        user_prompt = f"""
DEBATE TOPIC: "{topic}"
YOUR POSITION ({self.role.upper()}): "{stance_statement}"

Generate 2-3 core arguments that support your position. Each argument should be a clear, specific claim that can be strengthened with evidence.

Format your response as a JSON object:
{{
  "core_arguments": [
    {{
      "argument": "Your first core argument as a clear statement",
      "rationale": "Brief explanation of why this argument supports your position"
    }},
    {{
      "argument": "Your second core argument as a clear statement", 
      "rationale": "Brief explanation of why this argument supports your position"
    }},
    {{
      "argument": "Your third core argument as a clear statement",
      "rationale": "Brief explanation of why this argument supports your position"
    }}
  ]
}}

Respond in the SAME LANGUAGE as the debate topic.
"""

        response = self.llm_manager.generate_response(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            llm_model="gpt-4o",
            max_tokens=1000
        )
        
        # JSON íŒŒì‹±
        try:
            import json
            import re
            
            json_pattern = r'\{.*\}'
            json_match = re.search(json_pattern, response, re.DOTALL)
            
            if json_match:
                json_str = json_match.group(0)
                result = json.loads(json_str)
                self.core_arguments = result.get("core_arguments", [])
                logger.info(f"[{self.agent_id}] Generated {len(self.core_arguments)} core arguments")
            else:
                logger.warning(f"[{self.agent_id}] Failed to parse core arguments JSON")
                self.core_arguments = []
                
        except Exception as e:
            logger.error(f"[{self.agent_id}] Error parsing core arguments: {str(e)}")
            self.core_arguments = []
    
    def _generate_rag_queries_for_arguments(self, topic: str) -> None:
        """
        ê° í•µì‹¬ ì£¼ì¥ì— ëŒ€í•œ RAG ì¿¼ë¦¬ì™€ ê²€ìƒ‰ ì†ŒìŠ¤ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
        """
        self.argument_queries = []
        
        for i, arg_data in enumerate(self.core_arguments):
            argument = arg_data.get("argument", "")
            
            # ê° ì£¼ì¥ì— ëŒ€í•œ RAG ì¿¼ë¦¬ ìƒì„± (1ê°œë§Œ)
            system_prompt = """
You are an expert research assistant that generates specific search queries to find evidence supporting debate arguments.

For the given argument, generate 1 specific search query that would help find the most relevant supporting evidence, examples, case studies, or data.
Also determine the most appropriate source for the query from: web, user_context, dialogue_history, philosopher_works
"""

            user_prompt = f"""
DEBATE TOPIC: "{topic}"
ARGUMENT TO SUPPORT: "{argument}"

Generate 1 specific search query IN ENGLISH that would help find the best evidence to support this argument.
Also determine the most appropriate source to search from:
- web: For current facts, statistics, recent cases
- user_context: For documents, papers, provided materials
- dialogue_history: For previous statements in the debate
- philosopher_works: For philosophical concepts and theories

Format your response as JSON:
{{
  "query": "specific search query in English",
  "source": "most appropriate source",
  "reasoning": "why this source is appropriate"
}}
"""

            response = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",  # gpt-4 â†’ gpt-4o
                max_tokens=1200  # 800 â†’ 1200 (JSON íŒŒì‹±ì´ ë³µì¡í•¨)
            )
            
            # JSON íŒŒì‹±
            try:
                import json
                import re
                
                json_pattern = r'\{.*\}'
                json_match = re.search(json_pattern, response, re.DOTALL)
                
                if json_match:
                    json_str = json_match.group(0)
                    result = json.loads(json_str)
                    query = result.get("query", "")
                    source = result.get("source", "web")
                    reasoning = result.get("reasoning", "")
                    
                    self.argument_queries.append({
                        "argument_index": i,
                        "argument": argument,
                        "evidence": [{
                            "query": query,
                            "source": source,
                            "reasoning": reasoning,
                            "results": []  # RAG ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì €ì¥í•  ê³µê°„
                        }]
                    })
                    
                    logger.info(f"[{self.agent_id}] Generated 1 query for argument {i+1}: '{query}' from {source}")
                else:
                    logger.warning(f"[{self.agent_id}] Failed to parse query JSON for argument {i+1}")
                    # Fallback: ê¸°ë³¸ ì¿¼ë¦¬ ìƒì„±
                    self.argument_queries.append({
                        "argument_index": i,
                        "argument": argument,
                        "evidence": [{
                            "query": f"evidence for {argument[:50]}",
                            "source": "web",
                            "reasoning": "fallback query",
                            "results": []
                        }]
                    })
                    
            except Exception as e:
                logger.error(f"[{self.agent_id}] Error parsing query for argument {i+1}: {str(e)}")
                # Fallback: ê¸°ë³¸ ì¿¼ë¦¬ ìƒì„±
                self.argument_queries.append({
                    "argument_index": i,
                    "argument": argument,
                    "evidence": [{
                        "query": f"evidence for {argument[:50]}",
                        "source": "web",
                        "reasoning": "fallback query due to parsing error",
                        "results": []
                    }]
                })
    
    def _strengthen_arguments_with_rag(self) -> None:
        """
        ëª¨ë“  í•µì‹¬ ì£¼ì¥ë“¤ì„ RAG ê²€ìƒ‰ ê²°ê³¼ë¡œ ê°•í™”
        """
        logger.info(f"[{self.agent_id}] Starting RAG search and argument strengthening...")
        
        try:
            # ëª¨ë“  ì¿¼ë¦¬ì— ëŒ€í•´ ê²€ìƒ‰ ìˆ˜í–‰
            for query_data in self.argument_queries:
                for evidence in query_data.get("evidence", []):
                    query = evidence.get("query", "")
                    source = evidence.get("source", "web")
                    
                    logger.info(f"[{self.agent_id}] Processing query: '{query}' from source: '{source}'")
                    
                    # ì†ŒìŠ¤ë³„ ê²€ìƒ‰ ìˆ˜í–‰
                    if source == "web":
                        results = self._web_search(query)
                    elif source == "user_context":
                        results = self._vector_search(query)
                    elif source == "dialogue_history":
                        results = self._dialogue_search(query)
                    elif source == "philosopher_works":
                        results = self._philosopher_search(query)
                    else:
                        results = self._web_search(query)  # ê¸°ë³¸ê°’
                    
                    evidence["results"] = results
                    logger.info(f"[{self.agent_id}] Found {len(results)} results for query from {source}")
            
            # ì´ì œ ê° í•µì‹¬ ì£¼ì¥ì„ RAG ê²°ê³¼ë¡œ ì‹¤ì œ ê°•í™”
            self._actually_strengthen_arguments()
                    
        except Exception as e:
            logger.error(f"[{self.agent_id}] Error in RAG search: {str(e)}")
        
        logger.info(f"[{self.agent_id}] RAG search and argument strengthening completed")
    
    def _actually_strengthen_arguments(self) -> None:
        """
        RAG ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œë¡œ ê° í•µì‹¬ ì£¼ì¥ì„ ê°•í™”
        """
        logger.info(f"[{self.agent_id}] Starting actual argument strengthening...")
        
        strengthened_arguments = []
        
        for i, core_arg in enumerate(self.core_arguments):
            original_argument = core_arg.get("argument", "")
            original_reasoning = core_arg.get("reasoning", "")
            
            logger.info(f"[{self.agent_id}] Strengthening argument {i+1}: {original_argument[:100]}...")
            
            # í•´ë‹¹ ì£¼ì¥ê³¼ ê´€ë ¨ëœ RAG ê²°ê³¼ ìˆ˜ì§‘
            relevant_evidence = []
            if i < len(self.argument_queries):
                query_data = self.argument_queries[i]
                for evidence in query_data.get("evidence", []):
                    for result in evidence.get("results", []):
                        if result.get("relevance", 0) > 0.5:  # ê´€ë ¨ë„ 0.5 ì´ìƒë§Œ
                            relevant_evidence.append({
                                "content": result.get("content", ""),
                                "title": result.get("title", ""),
                                "url": result.get("url", ""),
                                "relevance": result.get("relevance", 0),
                                "source": result.get("source", "web")
                            })
            
            # ê´€ë ¨ë„ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  ìƒìœ„ 3ê°œë§Œ ì‚¬ìš©
            relevant_evidence.sort(key=lambda x: x.get("relevance", 0), reverse=True)
            top_evidence = relevant_evidence[:3]
            
            if top_evidence:
                # LLMì„ ì‚¬ìš©í•˜ì—¬ ì£¼ì¥ ê°•í™”
                strengthened = self._strengthen_single_argument_with_evidence(
                    original_argument, original_reasoning, top_evidence
                )
                
                # ê°•í™”ëœ ì£¼ì¥ìœ¼ë¡œ ì—…ë°ì´íŠ¸
                core_arg["argument"] = strengthened.get("strengthened_argument", original_argument)
                core_arg["reasoning"] = strengthened.get("strengthened_reasoning", original_reasoning)
                core_arg["evidence_used"] = len(top_evidence)
                core_arg["evidence_sources"] = [e.get("title", "Unknown") for e in top_evidence]
                
                strengthened_arguments.append({
                    "index": i+1,
                    "original": original_argument,
                    "strengthened": strengthened.get("strengthened_argument", original_argument),
                    "evidence_count": len(top_evidence),
                    "evidence_sources": [e.get("title", "Unknown") for e in top_evidence],
                    "top_relevance": top_evidence[0].get("relevance", 0) if top_evidence else 0
                })
                
                logger.info(f"[{self.agent_id}] Argument {i+1} strengthened with {len(top_evidence)} evidence pieces")
            else:
                # ì¦ê±°ê°€ ì—†ìœ¼ë©´ ì›ë³¸ ìœ ì§€
                strengthened_arguments.append({
                    "index": i+1,
                    "original": original_argument,
                    "strengthened": original_argument,
                    "evidence_count": 0,
                    "evidence_sources": [],
                    "top_relevance": 0
                })
                logger.info(f"[{self.agent_id}] Argument {i+1} kept original (no relevant evidence)")
        
        # ê°•í™”ëœ ì£¼ì¥ë“¤ì„ ë¡œê·¸ë¡œ ì¶œë ¥
        self._log_strengthened_arguments(strengthened_arguments)
    
    def _strengthen_single_argument_with_evidence(self, argument: str, reasoning: str, evidence_list: List[Dict[str, Any]]) -> Dict[str, str]:
        """
        ë‹¨ì¼ ì£¼ì¥ì„ ì¦ê±°ë¡œ ê°•í™”
        """
        evidence_summary = "\n".join([
            f"â€¢ {ev.get('title', 'Unknown')}: {ev.get('content', '')[:200]}... (ê´€ë ¨ë„: {ev.get('relevance', 0):.2f})"
            for ev in evidence_list
        ])
        
        system_prompt = f"""
You are {self.philosopher_name}, a great philosopher who strengthens arguments with evidence while maintaining your philosophical essence.

Your task: Take an original philosophical argument and strengthen it using provided evidence, while keeping your unique philosophical perspective dominant.

Guidelines:
1. Preserve the core philosophical reasoning (70% weight)
2. Integrate evidence naturally to support your philosophical claims (30% weight)
3. Make evidence feel like validation of your philosophical insight, not replacement
4. Keep your unique thinking style and terminology
5. Enhance the argument's persuasive power without losing philosophical depth
"""

        user_prompt = f"""
Original Argument: {argument}
Original Reasoning: {reasoning}

Available Evidence:
{evidence_summary}

Strengthen this argument by:
1. Keeping the core philosophical reasoning intact
2. Naturally weaving in the most relevant evidence
3. Making the evidence support your philosophical perspective
4. Enhancing logical flow and persuasive power
5. Maintaining your distinctive philosophical voice

Return ONLY a JSON object with:
{{"strengthened_argument": "enhanced version of the argument", "strengthened_reasoning": "enhanced reasoning with evidence integration"}}
"""

        try:
            response = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=800
            )
            
            # JSON íŒŒì‹± ì‹œë„
            import json
            import re
            
            # JSON ë¶€ë¶„ ì¶”ì¶œ
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                parsed = json.loads(json_str)
                return {
                    "strengthened_argument": parsed.get("strengthened_argument", argument),
                    "strengthened_reasoning": parsed.get("strengthened_reasoning", reasoning)
                }
        except Exception as e:
            logger.warning(f"[{self.agent_id}] Failed to strengthen argument with LLM: {str(e)}")
        
        # ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
        return {
            "strengthened_argument": argument,
            "strengthened_reasoning": reasoning
        }
    
    def _log_strengthened_arguments(self, strengthened_arguments: List[Dict[str, Any]]) -> None:
        """
        ê°•í™”ëœ ì£¼ì¥ë“¤ì„ ë¡œê·¸ë¡œ ì¶œë ¥
        """
        logger.info(f"[{self.agent_id}] ===============================================")
        logger.info(f"[{self.agent_id}] ğŸ“ˆ RAGë¡œ ê°•í™”ëœ ì£¼ì¥ë“¤ (ì´ {len(strengthened_arguments)}ê°œ)")
        logger.info(f"[{self.agent_id}] ===============================================")
        
        for arg_data in strengthened_arguments:
            logger.info(f"[{self.agent_id}] ")
            logger.info(f"[{self.agent_id}] ğŸ¯ ì£¼ì¥ {arg_data['index']}:")
            logger.info(f"[{self.agent_id}] ğŸ“Š ì¦ê±° ê°œìˆ˜: {arg_data['evidence_count']}ê°œ")
            logger.info(f"[{self.agent_id}] ğŸ“ˆ ìµœê³  ê´€ë ¨ë„: {arg_data['top_relevance']:.3f}")
            logger.info(f"[{self.agent_id}] ğŸ“š ì¦ê±° ì¶œì²˜: {', '.join(arg_data['evidence_sources'][:2])}{'...' if len(arg_data['evidence_sources']) > 2 else ''}")
            logger.info(f"[{self.agent_id}] ")
            logger.info(f"[{self.agent_id}] ğŸ”¹ ì›ë³¸ ì£¼ì¥:")
            logger.info(f"[{self.agent_id}]   {arg_data['original']}")
            logger.info(f"[{self.agent_id}] ")
            logger.info(f"[{self.agent_id}] âœ¨ ê°•í™”ëœ ì£¼ì¥:")
            logger.info(f"[{self.agent_id}]   {arg_data['strengthened']}")
            logger.info(f"[{self.agent_id}] ")
        
        total_evidence = sum(arg['evidence_count'] for arg in strengthened_arguments)
        strengthened_count = sum(1 for arg in strengthened_arguments if arg['evidence_count'] > 0)
        
        logger.info(f"[{self.agent_id}] ===============================================")
        logger.info(f"[{self.agent_id}] ğŸ“Š ê°•í™” ìš”ì•½:")
        logger.info(f"[{self.agent_id}]   - ì´ ì‚¬ìš©ëœ ì¦ê±°: {total_evidence}ê°œ")
        logger.info(f"[{self.agent_id}]   - ê°•í™”ëœ ì£¼ì¥: {strengthened_count}/{len(strengthened_arguments)}ê°œ")
        logger.info(f"[{self.agent_id}]   - ê°•í™” ì„±ê³µë¥ : {strengthened_count/len(strengthened_arguments)*100:.1f}%")
        logger.info(f"[{self.agent_id}] ===============================================")
    
    def _web_search(self, query: str) -> List[Dict[str, Any]]:
        "web crawling ì—†ì„ ì‹œ snippet ë§Œ ì‚¬ìš©"
        if not self.web_crawling:
            try:
                if not hasattr(self, 'web_retriever') or self.web_retriever is None:
                    from ...rag.retrieval.web_retriever import WebSearchRetriever
                    self.web_retriever = WebSearchRetriever(
                        embedding_model="all-MiniLM-L6-v2",
                        search_provider="google",
                        max_results=3
                    )
                
                # ì‹¤ì œ ì›¹ ê²€ìƒ‰ ìˆ˜í–‰
                web_results = self.web_retriever.search(query, 3)
                
                if web_results:
                    results = []
                    for item in web_results:
                        results.append({
                            "title": item.get("title", ""),
                            "content": item.get("snippet", ""),
                            "url": item.get("url", ""),
                            "source": "web",
                            "relevance": 0.85
                        })
                    return results
                else:
                    # ì‹¤ì œ ê²€ìƒ‰ ì‹¤íŒ¨ ì‹œ fallback
                    return []
                    
            except Exception as e:
                logger.warning(f"[{self.agent_id}] Web search failed, using mock data: {str(e)}")
                return []

        else:
            """ì‹¤ì œ ì›¹ ê²€ìƒ‰ ìˆ˜í–‰ (ê° ë…¼ì§€ë‹¹ ìµœëŒ€ 10ê°œ ê²°ê³¼)"""
            try:
                # WebSearchRetriever ì´ˆê¸°í™” (í•„ìš”ì‹œ)
                if not hasattr(self, 'web_retriever') or self.web_retriever is None:
                    from sapiens_engine.retrieval.web_retriever import WebSearchRetriever
                    self.web_retriever = WebSearchRetriever(
                        search_provider="google",
                        max_results=3,
                        cache_dir="./.cache/web_search_debate",
                        embedding_model="BAAI/bge-large-en-v1.5"
                    )
                
                # ì‹¤ì œ ì›¹ ê²€ìƒ‰ + í¬ë¡¤ë§ + ì²­í¬í™”
                extracted_chunks = self.web_retriever.retrieve_and_extract(
                    query=query,
                    max_pages=3,
                    chunk_size=500,
                    chunk_overlap=50,
                    rerank=True
                )
                
                if extracted_chunks:
                    results = []
                    # ê° ë…¼ì§€ë‹¹ ìµœëŒ€ 10ê°œë¡œ ì œí•œ
                    for chunk in extracted_chunks[:10]:
                        results.append({
                            "title": chunk["metadata"].get("title", "Web Content"),
                            "content": chunk["text"],
                            "url": chunk["metadata"].get("url", ""),
                            "source": "web",
                            "relevance": chunk.get("similarity", 0.85),
                            "score": chunk.get("score", 0.85),
                            "domain": chunk["metadata"].get("domain", ""),
                            "word_count": chunk["metadata"].get("word_count", 0)
                        })
                    
                    logger.info(f"[{self.agent_id}] Retrieved {len(results)} web chunks (limited to 10)")
                    return results
                else:
                    logger.warning(f"[{self.agent_id}] No web chunks retrieved for query: {query}")
                    return []
                    
            except Exception as e:
                logger.warning(f"[{self.agent_id}] Web search failed: {str(e)}")
                return []
    
    def _vector_search(self, query: str) -> List[Dict[str, Any]]:
        """ì‹¤ì œ ë²¡í„° ê²€ìƒ‰ ìˆ˜í–‰ (ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸)"""
        try:
            # í† ë¡  ëŒ€í™” ê°ì²´ì—ì„œ ë²¡í„° ì €ì¥ì†Œ ê°€ì ¸ì˜¤ê¸°
            if hasattr(self, 'vector_store') and self.vector_store is not None:
                vector_results = self.vector_store.search(query, 3)
                
                if vector_results:
                    results = []
                    for item in vector_results:
                        results.append({
                            "title": f"Document {item.get('id', '')}",
                            "content": item.get("text", ""),
                            "metadata": item.get("metadata", {}),
                            "source": "user_context",
                            "relevance": 1 - item.get("score", 0)  # ê±°ë¦¬ë¥¼ ê´€ë ¨ì„±ìœ¼ë¡œ ë³€í™˜
                        })
                    return results
            
            return []
            
        except Exception as e:
            logger.warning(f"[{self.agent_id}] Vector search failed: {str(e)}")
            return []
    
    def _dialogue_search(self, query: str) -> List[Dict[str, Any]]:
        """ì‹¤ì œ ëŒ€í™” ê¸°ë¡ ê²€ìƒ‰ ìˆ˜í–‰"""
        try:
            results = []
            
            # ëŒ€í™” ê¸°ë¡ì´ ìˆëŠ” ê²½ìš° ê²€ìƒ‰
            if hasattr(self, 'dialogue_history') and self.dialogue_history:
                keywords = query.lower().split()
                
                for msg in self.dialogue_history:
                    text = msg.get("text", "").lower()
                    if any(kw in text for kw in keywords):
                        results.append({
                            "speaker": msg.get("speaker", "Unknown"),
                            "content": msg.get("text", ""),
                            "timestamp": msg.get("timestamp", ""),
                            "source": "dialogue_history",
                            "relevance": 0.75
                        })
                
                # ê´€ë ¨ì„± ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  ìƒìœ„ 3ê°œë§Œ ë°˜í™˜
                results.sort(key=lambda x: x.get("relevance", 0), reverse=True)
                return results[:3]
            
            return []
            
        except Exception as e:
            logger.warning(f"[{self.agent_id}] Dialogue search failed: {str(e)}")
            return []
    
    def _philosopher_search(self, query: str) -> List[Dict[str, Any]]:
        """ì‹¤ì œ ì² í•™ì ì‘í’ˆ ê²€ìƒ‰ ìˆ˜í–‰"""
        try:
            # ì² í•™ì ì‘í’ˆ ë²¡í„° ì €ì¥ì†Œ í™œìš©
            if hasattr(self, 'philosopher_vector_store') and self.philosopher_vector_store is not None:
                vector_results = self.philosopher_vector_store.search(query, 3)
                
                if vector_results:
                    results = []
                    for item in vector_results:
                        results.append({
                            "title": f"Philosophical work on: {query[:30]}...",
                            "content": item.get("text", ""),
                            "author": item.get("metadata", {}).get("author", "Relevant Philosopher"),
                            "work": item.get("metadata", {}).get("work", "Famous Work"),
                            "source": "philosopher_works",
                            "relevance": 1 - item.get("score", 0)
                        })
                    return results
            
            # ì² í•™ì ë²¡í„° ì €ì¥ì†Œê°€ ì—†ëŠ” ê²½ìš° ì¼ë°˜ ë²¡í„° ê²€ìƒ‰ ì‹œë„
            elif hasattr(self, 'vector_store') and self.vector_store is not None:
                vector_results = self.vector_store.search(f"philosophy {query}", 2)
                
                if vector_results:
                    results = []
                    for item in vector_results:
                        results.append({
                            "title": f"Philosophical perspective: {query[:30]}...",
                            "content": item.get("text", ""),
                            "author": "Relevant Philosopher",
                            "work": "Academic Work",
                            "source": "philosopher_works",
                            "relevance": 1 - item.get("score", 0)
                        })
                    return results
            
            return []
            
        except Exception as e:
            logger.warning(f"[{self.agent_id}] Philosopher search failed: {str(e)}")
            return []
    
    def _generate_final_opening_argument(self, topic: str, stance_statement: str) -> None:
        """
        ê°•í™”ëœ ì£¼ì¥ë“¤ì„ ê²°í•©í•˜ì—¬ ìµœì¢… ì…ë¡  ìƒì„± (ì§„ì •í•œ ì² í•™ 70% + ë°ì´í„° 30% ê· í˜•)
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            stance_statement: ì…ì¥ ì§„ìˆ ë¬¸
        """
        logger.info(f"[{self.agent_id}] Generating final opening argument using strengthened arguments...")
        
        # ê°•í™”ëœ ì£¼ì¥ë“¤ì„ í¬ë§·íŒ…
        strengthened_args_text = []
        evidence_summary = []
        
        for i, core_arg in enumerate(self.core_arguments):
            strengthened_arg = core_arg.get("argument", "")
            strengthened_reasoning = core_arg.get("reasoning", "")
            evidence_count = core_arg.get("evidence_used", 0)
            evidence_sources = core_arg.get("evidence_sources", [])
            
            # ê°•í™”ëœ ì£¼ì¥ í…ìŠ¤íŠ¸
            if evidence_count > 0:
                strengthened_args_text.append(
                    f"{i+1}. {strengthened_arg}\n   ê·¼ê±°: {strengthened_reasoning}\n   (ì§€ì› ì¦ê±°: {evidence_count}ê°œ - {', '.join(evidence_sources[:2])})"
                )
                
                # ì¦ê±° ìš”ì•½ì— ì¶”ê°€
                evidence_summary.append(f"ì£¼ì¥ {i+1}: {evidence_count}ê°œ ì¦ê±° ({', '.join(evidence_sources[:2])})")
            else:
                strengthened_args_text.append(
                    f"{i+1}. {strengthened_arg}\n   ê·¼ê±°: {strengthened_reasoning}\n   (ìˆœìˆ˜ ì² í•™ì  ë…¼ì¦)"
                )
        
        # ì² í•™ì ì¤‘ì‹¬ í”„ë¡¬í”„íŠ¸ (ê°•í™”ëœ ì£¼ì¥ ê¸°ë°˜)
        system_prompt = f"""
You are {self.philosopher_name}, delivering a powerful opening argument using your strengthened philosophical arguments.

Your essence: {self.philosopher_essence}
Your debate style: {self.philosopher_debate_style}
Your personality: {self.philosopher_personality}
Key traits: {", ".join(self.philosopher_key_traits) if self.philosopher_key_traits else "logical reasoning"}

CRITICAL BALANCE (70% Philosophy + 30% Evidence Integration):
1. Your arguments have been strengthened with evidence, but YOU remain the primary voice (70%)
2. The evidence supports your philosophical perspective, not the other way around (30%)
3. Weave the strengthened reasoning naturally into your philosophical narrative
4. Maintain your unique thinking style while showing evidence validates your insights
5. Include preemptive counterarguments using your philosophical wisdom
6. Your famous quote: "{self.philosopher_quote}" - let this guide your entire argument

INTEGRATION STYLE:
- Philosophy dominates: Your reasoning and perspective lead the argument
- Evidence supports: When evidence is present, it validates your philosophical claims
- Return to philosophy: Always conclude with philosophical wisdom

Remember: You're a great philosopher whose insights are validated by evidence, not a researcher with philosophical opinions.
"""

        user_prompt = f"""
TOPIC: "{topic}"
YOUR POSITION: "{stance_statement}"

STRENGTHENED PHILOSOPHICAL ARGUMENTS (Use these as the foundation):
{chr(10).join(strengthened_args_text)}

EVIDENCE INTEGRATION SUMMARY:
{chr(10).join(evidence_summary) if evidence_summary else "Pure philosophical reasoning - no external evidence needed"}

Create a compelling 4-5 paragraph opening argument that showcases your strengthened arguments:

1. **Opening Statement** (Pure Philosophy): Present your philosophical position with confidence
2. **Strengthened Core Arguments**: Present your 2-3 main arguments using the strengthened versions above
3. **Evidence Integration**: Where evidence exists, show how it validates your philosophical insights
4. **Preemptive Defense**: Address counterarguments using your philosophical wisdom
5. **Philosophical Conclusion**: End with your wisdom and philosophical insight

INTEGRATION RULES:
- Use the strengthened arguments as provided - they already balance philosophy and evidence
- Focus on your philosophical perspective while naturally including evidence-backed reasoning
- When evidence is mentioned, show how it confirms your philosophical understanding
- Make evidence feel like natural validation of your insights, not separate data points

REQUIREMENTS:
- Write as {self.philosopher_name} would think and speak
- Prioritize philosophical depth while utilizing the strengthened arguments
- Make your philosophical reasoning the star, with evidence as supporting validation
- Respond in the same language as the topic
- Aim for 350-450 words of substantive philosophical argument

Balance: 70% your unique philosophical perspective + 30% evidence integration (already balanced in strengthened arguments).
"""

        self.prepared_argument = self.llm_manager.generate_response(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            llm_model="gpt-4o",
            max_tokens=1300
        )
        
        # ì‚¬ìš©ëœ ì¦ê±° ê°œìˆ˜ ê³„ì‚°
        total_evidence = sum(core_arg.get("evidence_used", 0) for core_arg in self.core_arguments)
        strengthened_count = sum(1 for core_arg in self.core_arguments if core_arg.get("evidence_used", 0) > 0)
        
        logger.info(f"[{self.agent_id}] Philosophy-focused opening argument generated ({len(self.prepared_argument)} characters)")
        logger.info(f"[{self.agent_id}] Used {total_evidence} evidence pieces across {strengthened_count} strengthened arguments")
        logger.info(f"[{self.agent_id}] Final argument incorporates strengthened philosophical reasoning")
    
    def _extract_key_data(self, content: str, metadata: Dict[str, Any]) -> str:
        """
        ì½˜í…ì¸ ì—ì„œ ê°€ì¥ í•µì‹¬ì ì¸ ë°ì´í„°ë§Œ ì¶”ì¶œ (1ê°œ ì¦ê±°ìš©)
        
        Args:
            content: ì›ë³¸ ì½˜í…ì¸ 
            metadata: ë©”íƒ€ë°ì´í„°
            
        Returns:
            í•µì‹¬ ë°ì´í„° ìš”ì•½ (ë§¤ìš° ê°„ê²°í•¨)
        """
        key_data = []
        
        # í†µê³„ ë°ì´í„° ìš°ì„  (1ê°œë§Œ)
        if metadata.get('statistics'):
            key_data.append(metadata['statistics'][0])  # ê°€ì¥ ì²« ë²ˆì§¸ë§Œ
        
        # ì—°êµ¬ ê²°ê³¼ (í†µê³„ê°€ ì—†ì„ ë•Œë§Œ)
        elif metadata.get('study_details'):
            key_data.append(metadata['study_details'][0])  # ê°€ì¥ ì²« ë²ˆì§¸ë§Œ
        
        # ì „ë¬¸ê°€ ì¸ìš© (ìœ„ì˜ ê²ƒë“¤ì´ ì—†ì„ ë•Œë§Œ)
        elif metadata.get('expert_quotes'):
            for quote in metadata['expert_quotes'][:1]:  # 1ê°œë§Œ
                if len(quote) < 100:  # ì§§ì€ ì¸ìš©ë§Œ
                    key_data.append(quote)
                    break
        
        # ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì½˜í…ì¸ ì—ì„œ í•µì‹¬ ë¬¸ì¥ 1ê°œë§Œ ì¶”ì¶œ
        if not key_data:
            import re
            # ìˆ«ìê°€ í¬í•¨ëœ ë¬¸ì¥ 1ê°œë§Œ ì°¾ê¸°
            sentences = re.split(r'[.!?]', content)
            for sentence in sentences:
                if re.search(r'\d+(?:\.\d+)?%|\d+(?:,\d+)*\s+(?:people|participants|cases|studies)', sentence):
                    clean_sentence = sentence.strip()
                    if len(clean_sentence) > 20 and len(clean_sentence) < 150:
                        key_data.append(clean_sentence)
                        break  # 1ê°œë§Œ ì°¾ìœ¼ë©´ ì¤‘ë‹¨
        
        return key_data[0] if key_data else "relevant research findings"
    
    def _extract_enhanced_metadata(self, content: str, title: str) -> Dict[str, Any]:
        """
        ì½˜í…ì¸ ì—ì„œ êµ¬ì²´ì  ë°ì´í„°ì™€ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
        
        Args:
            content: í…ìŠ¤íŠ¸ ì½˜í…ì¸ 
            title: ì†ŒìŠ¤ ì œëª©
            
        Returns:
            í–¥ìƒëœ ë©”íƒ€ë°ì´í„°
        """
        import re
        
        metadata = {
            'has_specific_data': False,
            'statistics': [],
            'study_details': [],
            'expert_quotes': [],
            'years': [],
            'authors': []
        }
        
        # í†µê³„ ë° ìˆ˜ì¹˜ ë°ì´í„° ì¶”ì¶œ
        # í¼ì„¼íŠ¸, ìˆ«ì, ì¸¡ì •ê°’ ë“±
        percentage_pattern = r'\b\d+(?:\.\d+)?%'
        number_pattern = r'\b\d{1,3}(?:,\d{3})*(?:\.\d+)?\s*(?:people|participants|subjects|patients|cases|studies|years|months|days|times|fold|million|billion|thousand)\b'
        measurement_pattern = r'\b\d+(?:\.\d+)?\s*(?:mg|kg|ml|cm|mm|meters?|feet|inches|hours?|minutes?|seconds?)\b'
        
        percentages = re.findall(percentage_pattern, content, re.IGNORECASE)
        numbers = re.findall(number_pattern, content, re.IGNORECASE)
        measurements = re.findall(measurement_pattern, content, re.IGNORECASE)
        
        if percentages:
            metadata['statistics'].extend([f"{p} change/improvement" for p in percentages[:3]])
            metadata['has_specific_data'] = True
            
        if numbers:
            metadata['statistics'].extend([f"{n}" for n in numbers[:3]])
            metadata['has_specific_data'] = True
            
        if measurements:
            metadata['statistics'].extend([f"{m}" for m in measurements[:2]])
            metadata['has_specific_data'] = True
        
        # ì—°êµ¬ ì„¸ë¶€ì‚¬í•­ ì¶”ì¶œ
        study_patterns = [
            r'(?:study|research|trial|experiment|analysis)\s+(?:of|with|involving)\s+(\d+(?:,\d+)*\s+(?:people|participants|subjects|patients))',
            r'(\d+(?:,\d+)*\s+(?:people|participants|subjects|patients))\s+(?:were|participated|enrolled)',
            r'(?:over|during|for)\s+(\d+\s+(?:years?|months?|weeks?|days?))',
            r'(?:randomized|controlled|double-blind|clinical)\s+(trial|study|experiment)',
            r'(?:published|reported|found)\s+in\s+(\d{4})',
            r'(?:university|institute|college)\s+(?:of\s+)?(\w+(?:\s+\w+)*)'
        ]
        
        for pattern in study_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                metadata['study_details'].extend([match if isinstance(match, str) else ' '.join(match) for match in matches[:2]])
                metadata['has_specific_data'] = True
        
        # ì „ë¬¸ê°€ ì¸ìš© ë° ë°œì–¸ ì¶”ì¶œ
        quote_patterns = [
            r'"([^"]{20,100})"',  # ë”°ì˜´í‘œ ì•ˆì˜ ì¸ìš©ë¬¸
            r'(?:according to|says|states|reports|found that|concluded that)\s+([^.]{20,80})',
            r'(?:Dr\.|Professor|researcher)\s+(\w+(?:\s+\w+)*)\s+(?:says|states|found|reported)',
        ]
        
        for pattern in quote_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                metadata['expert_quotes'].extend([match.strip() for match in matches[:2]])
                metadata['has_specific_data'] = True
        
        # ì—°ë„ ì¶”ì¶œ
        year_pattern = r'\b(19|20)\d{2}\b'
        years = re.findall(year_pattern, content)
        if years:
            metadata['years'] = [f"{y[0]}{y[1:]}" for y in years[:3]]
        
        # ì €ìëª… ì¶”ì¶œ (ê°„ë‹¨í•œ íŒ¨í„´)
        author_pattern = r'(?:Dr\.|Professor|by)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)'
        authors = re.findall(author_pattern, content)
        if authors:
            metadata['authors'] = authors[:2]
        
        return metadata
    
    def _hybrid_chunking(self, text: str, chunk_size: int = 800, overlap_ratio: float = 0.2) -> List[str]:
        """
        ë¬¸ì¥ ë‹¨ìœ„ + ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í•˜ì´ë¸Œë¦¬ë“œ ì²­í¬í™”
        ì •ë³´ ì†ì‹¤ì„ ìµœì†Œí™”í•˜ë©´ì„œ ì˜ë¯¸ ìˆëŠ” ë‹¨ìœ„ë¡œ í…ìŠ¤íŠ¸ ë¶„í• 
        
        Args:
            text: ì²­í¬í™”í•  í…ìŠ¤íŠ¸
            chunk_size: ëª©í‘œ ì²­í¬ í¬ê¸° (ë¬¸ì ìˆ˜)
            overlap_ratio: ì˜¤ë²„ë© ë¹„ìœ¨
            
        Returns:
            ì²­í¬ ë¦¬ìŠ¤íŠ¸
        """
        import re
        
        # ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„ë¦¬ (ê°œì„ ëœ íŒ¨í„´)
        sentence_pattern = r'(?<=[.!?])\s+(?=[A-Z])'
        sentences = re.split(sentence_pattern, text.strip())
        
        if not sentences:
            return [text]
        
        chunks = []
        current_chunk = ""
        overlap_size = int(chunk_size * overlap_ratio)
        
        for sentence in sentences:
            # í˜„ì¬ ì²­í¬ì— ë¬¸ì¥ì„ ì¶”ê°€í–ˆì„ ë•Œì˜ ê¸¸ì´ í™•ì¸
            potential_chunk = current_chunk + " " + sentence if current_chunk else sentence
            
            if len(potential_chunk) <= chunk_size:
                current_chunk = potential_chunk
            else:
                # í˜„ì¬ ì²­í¬ê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ì €ì¥
                if current_chunk:
                    chunks.append(current_chunk.strip())
                    
                    # ì˜¤ë²„ë©ì„ ìœ„í•´ í˜„ì¬ ì²­í¬ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„ ìœ ì§€
                    if len(current_chunk) > overlap_size:
                        # ë§ˆì§€ë§‰ overlap_size ë¬¸ìì—ì„œ ë¬¸ì¥ ê²½ê³„ ì°¾ê¸°
                        overlap_text = current_chunk[-overlap_size:]
                        # ë¬¸ì¥ ì‹œì‘ì  ì°¾ê¸°
                        sentence_start = overlap_text.find('. ')
                        if sentence_start != -1:
                            current_chunk = overlap_text[sentence_start + 2:]
                        else:
                            current_chunk = overlap_text
                    else:
                        current_chunk = ""
                
                # ìƒˆë¡œìš´ ë¬¸ì¥ìœ¼ë¡œ ì‹œì‘
                current_chunk = current_chunk + " " + sentence if current_chunk else sentence
        
        # ë§ˆì§€ë§‰ ì²­í¬ ì¶”ê°€
        if current_chunk:
            chunks.append(current_chunk.strip())
        
        return chunks
    
    def _get_stage_instructions(self, current_stage: str, topic: str, my_stance: str, opposite_stance: str) -> str:
        """
        í˜„ì¬ ë‹¨ê³„ì— ë§ëŠ” ì§€ì‹œì‚¬í•­ ë°˜í™˜
        
        Args:
            current_stage: í˜„ì¬ í† ë¡  ë‹¨ê³„
            topic: í† ë¡  ì£¼ì œ
            my_stance: ë‚´ ì…ì¥
            opposite_stance: ìƒëŒ€ë°© ì…ì¥
            
        Returns:
            ë‹¨ê³„ë³„ ì§€ì‹œì‚¬í•­
        """
        role_display = "PRO" if self.role == "pro" else "CON" if self.role == "con" else "NEUTRAL"
        
        stage_instructions = {
            "pro_argument": f"Present your main arguments. Clearly articulate 2-3 strong points supporting your position, back up each point with evidence or reasoning, and be persuasive and confident in your delivery.",
            
            "con_argument": f"Present your main arguments against the topic. Clearly articulate 2-3 strong points supporting your position, back up each point with evidence or reasoning, and be persuasive and confident in your delivery.",
            
            "pro_rebuttal": f"Rebut the arguments made by the opposition. Address the strongest points made by the CON side, point out logical flaws or factual errors in their arguments, and reinforce your own position.",
            
            "con_rebuttal": f"Rebut the arguments made by the opposition. Address the strongest points made by the PRO side, point out logical flaws or factual errors in their arguments, and reinforce your own position.",
            
            "con_to_pro_qa": f"{'Ask a pointed question to the PRO side that challenges their position' if self.role == 'con' else 'Answer the question from the CON side while defending your position'}.",
            
            "pro_to_con_qa": f"{'Ask a pointed question to the CON side that challenges their position' if self.role == 'pro' else 'Answer the question from the PRO side while defending your position'}.",
            
            "pro_conclusion": f"Deliver your closing statement. Summarize your strongest arguments, address key points raised during the debate, and reinforce why your position is correct.",
            
            "con_conclusion": f"Deliver your closing statement. Summarize your strongest arguments, address key points raised during the debate, and reinforce why your position is correct."
        }
        
        # ê¸°ë³¸ ì§€ì‹œì‚¬í•­
        default_instruction = f"Respond to the current discussion while advocating for your position: '{my_stance}'."
        
        return stage_instructions.get(current_stage, default_instruction)
    
    
    def _prepare_closing_statement(self, dialogue_state: Dict[str, Any], stance_statements: Dict[str, str]) -> str:
        """
        ìµœì¢… ê²°ë¡  ë°œì–¸ ì¤€ë¹„
        
        Args:
            dialogue_state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
            stance_statements: ì°¬ë°˜ ì…ì¥ ì§„ìˆ ë¬¸
            
        Returns:
            ìµœì¢… ê²°ë¡  ë°œì–¸
        """
        # ë‚´ ì…ì¥ í™•ì¸
        my_stance = stance_statements.get(self.role) if self.role in ["pro", "con"] else ""
        
        # ìµœì¢… ê²°ë¡  í…œí”Œë¦¿ (ì—­í• ë³„)
        if self.role == "pro":
            template = f"""ì§€ê¸ˆê¹Œì§€ì˜ í† ë¡ ì„ í†µí•´ ì €í¬ì˜ ì…ì¥ì„ ë‹¤ì‹œ í•œë²ˆ ê°•ì¡°í•˜ê³ ì í•©ë‹ˆë‹¤.

{my_stance}

ì˜¤ëŠ˜ í† ë¡ ì—ì„œ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¤‘ìš”í•œ ì ë“¤ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤:

ì²«ì§¸, [ì²« ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]
ë‘˜ì§¸, [ë‘ ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]  
ì…‹ì§¸, [ì„¸ ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]

ë”°ë¼ì„œ ì €í¬ëŠ” ê³„ì†í•´ì„œ ì´ ì…ì¥ì„ ì§€ì§€í•˜ë©°, ì´ê²ƒì´ ì˜¬ë°”ë¥¸ ë°©í–¥ì´ë¼ê³  í™•ì‹ í•©ë‹ˆë‹¤.

ê°ì‚¬í•©ë‹ˆë‹¤."""
        else:
            template = f"""ì§€ê¸ˆê¹Œì§€ì˜ í† ë¡ ì„ í†µí•´ ì €í¬ì˜ ì…ì¥ì„ ë‹¤ì‹œ í•œë²ˆ ê°•ì¡°í•˜ê³ ì í•©ë‹ˆë‹¤.

{my_stance}

ì˜¤ëŠ˜ í† ë¡ ì—ì„œ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¤‘ìš”í•œ ì ë“¤ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤:

ì²«ì§¸, [ì²« ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]
ë‘˜ì§¸, [ë‘ ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]
ì…‹ì§¸, [ì„¸ ë²ˆì§¸ í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½]

ë”°ë¼ì„œ ì €í¬ëŠ” ê³„ì†í•´ì„œ ì´ ì…ì¥ì„ ì§€ì§€í•˜ë©°, ì´ê²ƒì´ ì˜¬ë°”ë¥¸ ë°©í–¥ì´ë¼ê³  í™•ì‹ í•©ë‹ˆë‹¤.

ê°ì‚¬í•©ë‹ˆë‹¤."""
        
        return template
    
    def _update_interaction_history(self, prompt: str, response: str) -> None:
        """
        ìƒí˜¸ì‘ìš© ê¸°ë¡ ì—…ë°ì´íŠ¸
        
        Args:
            prompt: ì…ë ¥ëœ í”„ë¡¬í”„íŠ¸
            response: ìƒì„±ëœ ì‘ë‹µ
        """
        # interaction_historyê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
        if "interaction_history" not in self.state:
            self.state["interaction_history"] = []
            
        self.state["interaction_history"].append({
            "timestamp": time.time(),
            "prompt": prompt[:100] + "..." if len(prompt) > 100 else prompt,
            "response": response[:100] + "..." if len(response) > 100 else response
        })
        
        # ê¸°ë¡ì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì˜¤ë˜ëœ ê²ƒë¶€í„° ì œê±°
        if len(self.state["interaction_history"]) > 10:
            self.state["interaction_history"] = self.state["interaction_history"][-10:]
    
    def extract_opponent_key_points(self, opponent_messages: List[Dict[str, Any]]) -> None:
        """
        ìƒëŒ€ë°© ë°œì–¸ì—ì„œ í•µì‹¬ ë…¼ì  ì¶”ì¶œí•˜ì—¬ ì €ì¥
        ë‹¤ì¤‘ ìƒëŒ€ë°© ì§€ì›: ê° ìƒëŒ€ë°©ë³„ë¡œ ë…¼ì ì„ êµ¬ë¶„í•˜ì—¬ ì €ì¥
        
        Args:
            opponent_messages: ìƒëŒ€ë°© ë°œì–¸ ë©”ì‹œì§€ë“¤ (ì—¬ëŸ¬ ìƒëŒ€ë°© í¬í•¨ ê°€ëŠ¥)
        """
        if not opponent_messages:
            logger.warning(f"[{self.agent_id}] No opponent messages to extract key points from")
            return
        
        try:
            # ìƒëŒ€ë°©ë³„ë¡œ ë©”ì‹œì§€ ê·¸ë£¹í™”
            opponents_by_speaker = {}
            for msg in opponent_messages:
                speaker_id = msg.get("speaker_id", "unknown")
                text = msg.get("text", "").strip()
                if text:
                    if speaker_id not in opponents_by_speaker:
                        opponents_by_speaker[speaker_id] = []
                    opponents_by_speaker[speaker_id].append(text)
            
            if not opponents_by_speaker:
                logger.warning(f"[{self.agent_id}] No meaningful opponent text found")
                return
            
            # ëª¨ë“  ìƒëŒ€ë°©ì˜ ë…¼ì ì„ í†µí•©í•˜ì—¬ ì¶”ì¶œ
            all_opponent_text = ""
            speaker_summaries = []
            
            for speaker_id, texts in opponents_by_speaker.items():
                speaker_text = "\n".join(texts)
                all_opponent_text += f"\n\n[{speaker_id}]:\n{speaker_text}"
                speaker_summaries.append(f"- {speaker_id}: {len(texts)} statements")
            
            logger.info(f"[{self.agent_id}] Processing arguments from {len(opponents_by_speaker)} opponents: {', '.join(opponents_by_speaker.keys())}")
            
            # LLMì„ ì‚¬ìš©í•˜ì—¬ í†µí•© í•µì‹¬ ë…¼ì  ì¶”ì¶œ
            system_prompt = """
You are an expert debate analyst. Extract the key arguments and main points from multiple opponents' statements.
Focus on identifying:
1. Core claims and assertions from all opponents
2. Main supporting evidence or reasoning
3. Key logical structures
4. Common themes across different speakers
5. Unique arguments from individual speakers

Provide a comprehensive list that captures the essence of the opposition's position.
"""
            
            user_prompt = f"""
Analyze the following debate statements from multiple opponents and extract their key arguments:

OPPONENTS' STATEMENTS:
{all_opponent_text}

SPEAKER SUMMARY:
{chr(10).join(speaker_summaries)}

Extract 4-7 key points that represent the opponents' main arguments across all speakers. 
Include both common themes and unique individual arguments.

Format your response as a JSON list of strings:
["Key point 1", "Key point 2", "Key point 3", ...]

Each key point should be:
- A concise summary (1-2 sentences) of a major argument or claim
- Representative of the overall opposition position
- Include attribution if it's a unique argument from a specific speaker
"""
            
            response = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",  # gpt-4 â†’ gpt-4o
                max_tokens=1500  # 1000 â†’ 1500 (ìƒëŒ€ë°© ë…¼ì  ì¶”ì¶œì€ ë³µì¡í•  ìˆ˜ ìˆìŒ)
            )
            
            # JSON íŒŒì‹±
            import json
            import re
            
            # JSON ë°°ì—´ íŒ¨í„´ ì°¾ê¸°
            json_pattern = r'\[.*?\]'
            json_match = re.search(json_pattern, response, re.DOTALL)
            
            if json_match:
                json_str = json_match.group(0)
                key_points = json.loads(json_str)
                
                if isinstance(key_points, list):
                    self.opponent_key_points = key_points
                    logger.info(f"[{self.agent_id}] Extracted {len(key_points)} opponent key points from {len(opponents_by_speaker)} speakers")
                    
                    # ë””ë²„ê¹…ìš© ë¡œê·¸
                    for i, point in enumerate(key_points, 1):
                        logger.info(f"[{self.agent_id}] Opponent point {i}: {point[:100]}...")
                        
                    # ìƒëŒ€ë°©ë³„ ìƒì„¸ ì •ë³´ë„ ì €ì¥ (ì„ íƒì )
                    if not hasattr(self, 'opponent_details'):
                        self.opponent_details = {}
                    self.opponent_details['speakers'] = list(opponents_by_speaker.keys())
                    self.opponent_details['message_counts'] = {k: len(v) for k, v in opponents_by_speaker.items()}
                    
                else:
                    logger.warning(f"[{self.agent_id}] Invalid key points format: {type(key_points)}")
            else:
                logger.warning(f"[{self.agent_id}] Failed to parse key points from response: {response[:100]}...")
                
        except Exception as e:
            logger.error(f"[{self.agent_id}] Error extracting opponent key points: {str(e)}")
    
    def update_my_key_points_from_core_arguments(self) -> None:
        """
        ìì‹ ì˜ core_argumentsì—ì„œ my_key_points ì—…ë°ì´íŠ¸
        """
        try:
            if self.core_arguments:
                # core_argumentsê°€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœì¸ ê²½ìš°
                if isinstance(self.core_arguments[0], dict):
                    self.my_key_points = [
                        arg.get("argument", "") for arg in self.core_arguments
                        if arg.get("argument", "").strip()
                    ]
                # core_argumentsê°€ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš°
                else:
                    self.my_key_points = [
                        str(arg) for arg in self.core_arguments
                        if str(arg).strip()
                    ]
                
                logger.info(f"[{self.agent_id}] Updated my_key_points from {len(self.core_arguments)} core arguments")
            else:
                logger.warning(f"[{self.agent_id}] No core_arguments available to update my_key_points")
                
        except Exception as e:
            logger.error(f"[{self.agent_id}] Error updating my_key_points: {str(e)}")
    
    # ========================================================================
    # ARGUMENT PREPARATION STATE MANAGEMENT (Option 2 êµ¬í˜„)
    # ========================================================================
    
    def is_argument_ready(self) -> bool:
        """ì…ë¡ ì´ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ í™•ì¸"""
        return self.argument_prepared and self.argument_cache_valid and self.prepared_argument
    
    def is_currently_preparing(self) -> bool:
        """í˜„ì¬ ì…ë¡  ì¤€ë¹„ ì¤‘ì¸ì§€ í™•ì¸"""
        return self.is_preparing_argument
    
    async def prepare_argument_async(self, topic: str, stance_statement: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        ë¹„ë™ê¸°ë¡œ ì…ë¡  ì¤€ë¹„ (ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ìš©)
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            stance_statement: ì…ì¥ ì§„ìˆ ë¬¸
            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
            
        Returns:
            ì¤€ë¹„ ê²°ê³¼
        """
        if self.is_preparing_argument:
            return {"status": "already_preparing", "message": "ì´ë¯¸ ì…ë¡  ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤"}
        
        if self.is_argument_ready() and self._is_same_context(context):
            return {"status": "already_ready", "message": "ì…ë¡ ì´ ì´ë¯¸ ì¤€ë¹„ë˜ì–´ ìˆìŠµë‹ˆë‹¤"}
        
        try:
            self.is_preparing_argument = True
            self.last_preparation_context = context
            
            # ë¹„ë™ê¸°ë¡œ ì…ë¡  ì¤€ë¹„ ì‹¤í–‰
            import asyncio
            loop = asyncio.get_event_loop()
            
            def prepare_sync():
                self.prepare_argument_with_rag(topic, stance_statement, context)
                return {
                    "status": "success" if self.argument_prepared else "failed",
                    "prepared": self.argument_prepared,
                    "argument_length": len(self.prepared_argument) if self.prepared_argument else 0
                }
            
            result = await loop.run_in_executor(None, prepare_sync)
            
            if result["status"] == "success":
                self.argument_cache_valid = True
            
            return result
            
        except Exception as e:
            logger.error(f"Error in async argument preparation: {str(e)}")
            return {"status": "error", "error": str(e)}
        finally:
            self.is_preparing_argument = False
    
    def get_prepared_argument_or_generate(self, topic: str, stance_statement: str, context: Dict[str, Any] = None) -> str:
        """
        ì¤€ë¹„ëœ ì…ë¡ ì„ ë°˜í™˜í•˜ê±°ë‚˜, ì—†ìœ¼ë©´ ì¦‰ì‹œ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            stance_statement: ì…ì¥ ì§„ìˆ ë¬¸
            context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
            
        Returns:
            ì…ë¡  í…ìŠ¤íŠ¸
        """
        # ì¤€ë¹„ëœ ì…ë¡ ì´ ìˆê³  ìœ íš¨í•˜ë©´ ë°˜í™˜
        if self.is_argument_ready() and self._is_same_context(context):
            logger.info(f"[{self.agent_id}] Using cached prepared argument")
            return self.prepared_argument
        
        # ì—†ìœ¼ë©´ ì¦‰ì‹œ ìƒì„±
        logger.info(f"[{self.agent_id}] No cached argument available, generating immediately")
        self.prepare_argument_with_rag(topic, stance_statement, context)
        self.argument_cache_valid = True
        self.last_preparation_context = context
        
        return self.prepared_argument if self.prepared_argument else "ì…ë¡  ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
    
    def invalidate_argument_cache(self):
        """ì…ë¡  ìºì‹œ ë¬´íš¨í™”"""
        self.argument_cache_valid = False
        self.last_preparation_context = None
        logger.info(f"[{self.agent_id}] Argument cache invalidated")
    
    def _is_same_context(self, context: Dict[str, Any]) -> bool:
        """
        í˜„ì¬ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ì „ ì¤€ë¹„ ì‹œì™€ ë™ì¼í•œì§€ í™•ì¸
        
        Args:
            context: ë¹„êµí•  ì»¨í…ìŠ¤íŠ¸
            
        Returns:
            ë™ì¼ ì—¬ë¶€
        """
        if self.last_preparation_context is None:
            return False
        
        # ì£¼ìš” í•„ë“œë“¤ë§Œ ë¹„êµ
        key_fields = ["topic", "stance_statement", "current_stage"]
        for field in key_fields:
            if context.get(field) != self.last_preparation_context.get(field):
                return False
        
        return True
    
    def analyze_and_score_arguments(self, opponent_response: str, speaker_id: str) -> Dict[str, Any]:
        """
        ìƒëŒ€ë°© ë°œì–¸ì—ì„œ ë…¼ì§€ë¥¼ ì¶”ì¶œí•˜ê³  ìŠ¤ì½”ì–´ë§
        
        Args:
            opponent_response: ìƒëŒ€ë°© ë°œì–¸ í…ìŠ¤íŠ¸
            speaker_id: ë°œì–¸ì ID
            
        Returns:
            ë¶„ì„ ê²°ê³¼ (ë…¼ì§€ ëª©ë¡, ìŠ¤ì½”ì–´, ì·¨ì•½ì  ë“±)
        """
        try:
            # 1. ë…¼ì§€ ì¶”ì¶œ
            arguments = self._extract_arguments_from_response(opponent_response, speaker_id)
            
            # 2. ê° ë…¼ì§€ë³„ ìŠ¤ì½”ì–´ë§
            scored_arguments = []
            for arg in arguments:
                score_data = self._score_single_argument(arg, opponent_response)
                scored_arguments.append({
                    "argument": arg,
                    "scores": score_data,
                    "vulnerability_rank": score_data.get("final_vulnerability", 0.0)  # ê°œì„ ëœ ì·¨ì•½ì„± ì‚¬ìš©
                })
            
            # 3. ì·¨ì•½ì  ìˆœìœ¼ë¡œ ì •ë ¬
            scored_arguments.sort(key=lambda x: x["vulnerability_rank"], reverse=True)
            
            # 4. ìƒëŒ€ë°© ë…¼ì§€ ì €ì¥
            if speaker_id not in self.opponent_arguments:
                self.opponent_arguments[speaker_id] = []
            self.opponent_arguments[speaker_id].extend(scored_arguments)
            
            return {
                "status": "success",
                "speaker_id": speaker_id,
                "arguments_count": len(arguments),
                "scored_arguments": scored_arguments[:3],  # ìƒìœ„ 3ê°œë§Œ ë°˜í™˜
                "analysis_timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Error analyzing opponent arguments: {str(e)}")
            return {"error": str(e)}
    
    def _extract_arguments_from_response(self, response: str, speaker_id: str) -> List[Dict[str, Any]]:
        """
        ë°œì–¸ì—ì„œ í•µì‹¬ ë…¼ì§€ë“¤ì„ ì¶”ì¶œ
        
        Args:
            response: ë°œì–¸ í…ìŠ¤íŠ¸
            speaker_id: ë°œì–¸ì ID
            
        Returns:
            ì¶”ì¶œëœ ë…¼ì§€ ëª©ë¡
        """
        system_prompt = """
You are an expert debate analyst. Your task is to extract key arguments from a speaker's statement.
Identify the main claims, supporting evidence, and logical structure.
Return ONLY valid JSON format.
"""

        user_prompt = f"""
Analyze this debate statement and extract the key arguments:

STATEMENT: "{response}"

Extract the main arguments and return ONLY a valid JSON array:
[
  {{
    "claim": "main claim text",
    "evidence": "supporting evidence",
    "reasoning": "logical reasoning",
    "assumptions": ["assumption1", "assumption2"],
    "argument_type": "logical"
  }}
]

IMPORTANT: Return ONLY the JSON array, no other text.
"""
        
        try:
            response_text = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",  # gpt-4 â†’ gpt-4o
                max_tokens=1200  # 800 â†’ 1200 (JSON íŒŒì‹±ì´ ë³µì¡í•¨)
            )
            
            # JSON íŒŒì‹± ê°œì„ 
            import json
            import re
            
            # ì‘ë‹µì—ì„œ JSON ë¶€ë¶„ë§Œ ì¶”ì¶œ (ë” ê²¬ê³ í•œ ì •ê·œì‹)
            # ì¤‘ê´„í˜¸ë‚˜ ëŒ€ê´„í˜¸ë¡œ ì‹œì‘í•˜ëŠ” JSON ì°¾ê¸°
            json_patterns = [
                r'\[[\s\S]*?\]',  # ë°°ì—´ í˜•íƒœ
                r'\{[\s\S]*?\}',  # ê°ì²´ í˜•íƒœ
            ]
            
            parsed_data = None
            for pattern in json_patterns:
                matches = re.findall(pattern, response_text, re.DOTALL)
                for match in matches:
                    try:
                        # JSON ë¬¸ìì—´ ì •ë¦¬
                        clean_json = match.strip()
                        # ì˜ëª»ëœ ë¬¸ì ì œê±°
                        clean_json = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', clean_json)
                        
                        parsed_data = json.loads(clean_json)
                        
                        # ë°°ì—´ì´ ì•„ë‹ˆë©´ ë°°ì—´ë¡œ ê°ì‹¸ê¸°
                        if not isinstance(parsed_data, list):
                            parsed_data = [parsed_data]
                        
                        # ìœ íš¨í•œ JSONì„ ì°¾ì•˜ìœ¼ë©´ ì¤‘ë‹¨
                        break
                    except json.JSONDecodeError:
                        continue
                
                if parsed_data:
                    break
            
            if parsed_data:
                # ë°ì´í„° ê²€ì¦ ë° ì •ë¦¬
                validated_arguments = []
                for arg in parsed_data:
                    if isinstance(arg, dict):
                        validated_arg = {
                            "claim": str(arg.get('claim', 'Unknown claim')),
                            "evidence": str(arg.get('evidence', 'No evidence provided')),
                            "reasoning": str(arg.get('reasoning', 'No reasoning provided')),
                            "assumptions": arg.get('assumptions', []) if isinstance(arg.get('assumptions'), list) else [],
                            "argument_type": str(arg.get('argument_type', 'logical'))
                        }
                        validated_arguments.append(validated_arg)
                
                return validated_arguments if validated_arguments else self._get_fallback_argument(response)
            else:
                return self._get_fallback_argument(response)
                
        except Exception as e:
            logger.error(f"Error extracting arguments: {str(e)}")
            return self._get_fallback_argument(response)
    
    def _get_fallback_argument(self, response: str) -> List[Dict[str, Any]]:
        """JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë…¼ì§€ êµ¬ì¡° ë°˜í™˜"""
        return [{
            "claim": response[:200] + "..." if len(response) > 200 else response,
            "evidence": "Not extracted due to parsing error",
            "reasoning": "Not analyzed due to parsing error",
            "assumptions": [],
            "argument_type": "unknown"
        }]
    
    def _score_single_argument(self, argument: Dict[str, Any], full_context: str) -> Dict[str, float]:
        """
        ë‹¨ì¼ ë…¼ì§€ì— ëŒ€í•œ ë‹¤ì°¨ì› ìŠ¤ì½”ì–´ë§ (ê°œì„ ëœ ì·¨ì•½ì„± ë¶„ì„ í¬í•¨)
        
        Args:
            argument: ë¶„ì„í•  ë…¼ì§€
            full_context: ì „ì²´ ë°œì–¸ ë§¥ë½
            
        Returns:
            ìŠ¤ì½”ì–´ ë°ì´í„° (ë…¼ë¦¬ì  ê°•ë„, ê·¼ê±° í’ˆì§ˆ, ì„¸ë¶€ ì·¨ì•½ì„±, ê´€ë ¨ì„±, ìµœì¢… ì·¨ì•½ì„±)
        """
        # 1. ì„¸ë¶€ ì·¨ì•½ì„± ë¶„ì„ (LLM ì‚¬ìš©)
        detailed_vulnerabilities = self._analyze_detailed_vulnerabilities(argument, full_context)
        
        # 2. ì² í•™ìë³„ ë¯¼ê°ë„ ì ìš©í•œ ìµœì¢… ì·¨ì•½ì„± ì ìˆ˜ ê³„ì‚°
        final_vulnerability = self._calculate_personalized_vulnerability(detailed_vulnerabilities)
        
        # 3. ê¸°ì¡´ ìŠ¤ì½”ì–´ë§ (ë…¼ë¦¬ì  ê°•ë„, ê·¼ê±° í’ˆì§ˆ, ê´€ë ¨ì„±)
        basic_scores = self._get_basic_argument_scores(argument, full_context)
        
        # 4. í†µí•© ê²°ê³¼ ë°˜í™˜
        result = {
            **basic_scores,
            **detailed_vulnerabilities,
            "final_vulnerability": final_vulnerability,
            "overall_score": (
                basic_scores.get("logical_strength", 0.5) * 0.3 +
                basic_scores.get("evidence_quality", 0.5) * 0.25 +
                (1.0 - final_vulnerability) * 0.25 +  # ê°œì„ ëœ ì·¨ì•½ì„± ì‚¬ìš©
                basic_scores.get("relevance", 0.5) * 0.2
            )
        }
        
        return result
    
    def _analyze_detailed_vulnerabilities(self, argument: Dict[str, Any], full_context: str) -> Dict[str, float]:
        """
        ë…¼ì§€ì˜ ì„¸ë¶€ì ì¸ ì·¨ì•½ì„± ë¶„ì„
        
        Args:
            argument: ë¶„ì„í•  ë…¼ì§€
            full_context: ì „ì²´ ë°œì–¸ ë§¥ë½
            
        Returns:
            ì„¸ë¶€ ì·¨ì•½ì„± ì ìˆ˜ë“¤
        """
        print(f"   ğŸ” [{self.philosopher_name}] ì„¸ë¶€ ì·¨ì•½ì„± ë¶„ì„ ì‹œì‘:")
        print(f"      - ëŒ€ìƒ ë…¼ì§€: {argument.get('claim', '')[:100]}...")
        
        system_prompt = """
You are an expert argument analyzer. Evaluate the vulnerabilities of debate arguments on specific dimensions.
Be precise and objective in your assessment.
"""

        user_prompt = f"""
Analyze this argument for specific vulnerabilities (scale 0.0-1.0, where higher = more vulnerable):

ARGUMENT:
- Claim: {argument.get('claim', '')}
- Evidence: {argument.get('evidence', '')}
- Reasoning: {argument.get('reasoning', '')}
- Assumptions: {argument.get('assumptions', [])}

FULL CONTEXT: "{full_context}"

Evaluate these specific vulnerability dimensions:
1. CONCEPTUAL_CLARITY (0.0-1.0): How unclear or ambiguous are the key concepts?
2. LOGICAL_LEAP (0.0-1.0): How big are the logical gaps in reasoning?
3. OVERGENERALIZATION (0.0-1.0): How much does it generalize beyond evidence?
4. EMOTIONAL_APPEAL (0.0-1.0): How much does it rely on emotion over logic?
5. LACK_OF_CONCRETE_EVIDENCE (0.0-1.0): How lacking is specific, concrete evidence?

Return JSON format:
{{
  "conceptual_clarity": 0.0-1.0,
  "logical_leap": 0.0-1.0,
  "overgeneralization": 0.0-1.0,
  "emotional_appeal": 0.0-1.0,
  "lack_of_concrete_evidence": 0.0-1.0
}}
"""
        
        try:
            print(f"      ğŸ¤– LLM ë¶„ì„ ìš”ì²­ ì¤‘...")
            response_text = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",  # gpt-4 â†’ gpt-4o
                max_tokens=1200  # 800 â†’ 1200 (JSON íŒŒì‹±ì´ ë³µì¡í•¨)
            )
            
            print(f"      ğŸ“ LLM ì‘ë‹µ: {response_text[:200]}...")
            
            # JSON íŒŒì‹±
            import json
            import re
            json_pattern = r'\{.*?\}'
            json_match = re.search(json_pattern, response_text, re.DOTALL)
            
            if json_match:
                vulnerabilities = json.loads(json_match.group(0))
                # í‚¤ ì´ë¦„ ì •ê·œí™”
                result = {
                    "conceptual_clarity": vulnerabilities.get("conceptual_clarity", 0.5),
                    "logical_leap": vulnerabilities.get("logical_leap", 0.5),
                    "overgeneralization": vulnerabilities.get("overgeneralization", 0.5),
                    "emotional_appeal": vulnerabilities.get("emotional_appeal", 0.5),
                    "lack_of_concrete_evidence": vulnerabilities.get("lack_of_concrete_evidence", 0.5)
                }
                
                print(f"      âœ… ì„¸ë¶€ ì·¨ì•½ì„± ë¶„ì„ ì™„ë£Œ:")
                for vuln_type, score in result.items():
                    print(f"         â€¢ {vuln_type}: {score:.3f}")
                
                return result
            else:
                # ê¸°ë³¸ê°’
                print(f"      âŒ JSON íŒŒì‹± ì‹¤íŒ¨ - ê¸°ë³¸ê°’ ì‚¬ìš©")
                return {
                    "conceptual_clarity": 0.5,
                    "logical_leap": 0.5,
                    "overgeneralization": 0.5,
                    "emotional_appeal": 0.5,
                    "lack_of_concrete_evidence": 0.5
                }
                
        except Exception as e:
            logger.error(f"Error analyzing detailed vulnerabilities: {str(e)}")
            print(f"      âŒ ë¶„ì„ ì˜¤ë¥˜: {str(e)} - ê¸°ë³¸ê°’ ì‚¬ìš©")
            return {
                "conceptual_clarity": 0.5,
                "logical_leap": 0.5,
                "overgeneralization": 0.5,
                "emotional_appeal": 0.5,
                "lack_of_concrete_evidence": 0.5
            }
    
    def _calculate_personalized_vulnerability(self, detailed_vulnerabilities: Dict[str, float]) -> float:
        """
        ì² í•™ìë³„ ë¯¼ê°ë„ë¥¼ ì ìš©í•œ ê°œì¸í™”ëœ ì·¨ì•½ì„± ì ìˆ˜ ê³„ì‚°
        
        Args:
            detailed_vulnerabilities: ì„¸ë¶€ ì·¨ì•½ì„± ì ìˆ˜ë“¤
            
        Returns:
            ìµœì¢… ê°œì¸í™”ëœ ì·¨ì•½ì„± ì ìˆ˜ (0.0-1.0)
        """
        try:
            # ì² í•™ì ë°ì´í„°ì—ì„œ ë¯¼ê°ë„ ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            vulnerability_sensitivity = philosopher_data.get("vulnerability_sensitivity", {})
            
            print(f"   ğŸ§® [{self.philosopher_name}] ì·¨ì•½ì„± ì ìˆ˜ ê³„ì‚° ì‹œì‘:")
            print(f"      - ì² í•™ì í‚¤: {philosopher_key}")
            
            if not vulnerability_sensitivity:
                # ë¯¼ê°ë„ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ í‰ê· ê°’ ë°˜í™˜
                avg_score = sum(detailed_vulnerabilities.values()) / len(detailed_vulnerabilities)
                print(f"      âŒ ë¯¼ê°ë„ ë°ì´í„° ì—†ìŒ - í‰ê· ê°’ ì‚¬ìš©: {avg_score:.3f}")
                return avg_score
            
            print(f"      âœ… ë¯¼ê°ë„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ")
            print(f"      ğŸ“Š ì„¸ë¶€ ì·¨ì•½ì„±:")
            for vuln_type, score in detailed_vulnerabilities.items():
                print(f"         â€¢ {vuln_type}: {score:.3f}")
            
            print(f"      ğŸ¯ ì² í•™ì ë¯¼ê°ë„:")
            for vuln_type, sensitivity in vulnerability_sensitivity.items():
                print(f"         â€¢ {vuln_type}: {sensitivity:.3f}")
            
            # ë²¡í„° ë‚´ì  ê³„ì‚°: ì·¨ì•½ì„± * ë¯¼ê°ë„
            total_score = 0.0
            total_weight = 0.0
            
            print(f"      ğŸ”¢ ê³„ì‚° ê³¼ì •:")
            for vuln_type, vuln_score in detailed_vulnerabilities.items():
                sensitivity = vulnerability_sensitivity.get(vuln_type, 0.5)
                weighted_score = vuln_score * sensitivity
                total_score += weighted_score
                total_weight += sensitivity
                print(f"         â€¢ {vuln_type}: {vuln_score:.3f} Ã— {sensitivity:.3f} = {weighted_score:.3f}")
            
            print(f"      ğŸ“ˆ í•©ê³„:")
            print(f"         â€¢ ê°€ì¤‘í•©: {total_score:.3f}")
            print(f"         â€¢ ê°€ì¤‘ì¹˜í•©: {total_weight:.3f}")
            
            # ê°€ì¤‘í‰ê·  ê³„ì‚°
            if total_weight > 0:
                final_score = total_score / total_weight
                print(f"         â€¢ ìµœì¢…ì ìˆ˜: {total_score:.3f} Ã· {total_weight:.3f} = {final_score:.3f}")
            else:
                final_score = sum(detailed_vulnerabilities.values()) / len(detailed_vulnerabilities)
                print(f"         â€¢ ê°€ì¤‘ì¹˜í•©ì´ 0 - í‰ê· ê°’ ì‚¬ìš©: {final_score:.3f}")
            
            # 0.0-1.0 ë²”ìœ„ë¡œ í´ë¦¬í•‘
            clipped_score = max(0.0, min(1.0, final_score))
            if clipped_score != final_score:
                print(f"         â€¢ í´ë¦¬í•‘: {final_score:.3f} â†’ {clipped_score:.3f}")
            
            print(f"      ğŸ¯ [{self.philosopher_name}] ìµœì¢… ê°œì¸í™”ëœ ì·¨ì•½ì„±: {clipped_score:.3f}")
            print()
            
            return clipped_score
            
        except Exception as e:
            logger.error(f"Error calculating personalized vulnerability: {str(e)}")
            # ì˜¤ë¥˜ ì‹œ í‰ê· ê°’ ë°˜í™˜
            avg_score = sum(detailed_vulnerabilities.values()) / len(detailed_vulnerabilities)
            print(f"      âŒ ê³„ì‚° ì˜¤ë¥˜ - í‰ê· ê°’ ì‚¬ìš©: {avg_score:.3f}")
            return avg_score
    
    def _get_basic_argument_scores(self, argument: Dict[str, Any], full_context: str) -> Dict[str, float]:
        """
        ê¸°ë³¸ ë…¼ì§€ ìŠ¤ì½”ì–´ë§ (ë…¼ë¦¬ì  ê°•ë„, ê·¼ê±° í’ˆì§ˆ, ê´€ë ¨ì„±)
        
        Args:
            argument: ë¶„ì„í•  ë…¼ì§€
            full_context: ì „ì²´ ë°œì–¸ ë§¥ë½
            
        Returns:
            ê¸°ë³¸ ìŠ¤ì½”ì–´ë“¤
        """
        system_prompt = """
You are a debate argument evaluator. Score arguments on basic dimensions.
Be objective and analytical in your assessment.
"""

        user_prompt = f"""
Evaluate this argument on the following basic criteria (scale 0.0-1.0):

ARGUMENT:
- Claim: {argument.get('claim', '')}
- Evidence: {argument.get('evidence', '')}
- Reasoning: {argument.get('reasoning', '')}
- Assumptions: {argument.get('assumptions', [])}

FULL CONTEXT: "{full_context}"

Score on these dimensions:
1. LOGICAL_STRENGTH (0.0-1.0): How logically sound is the argument?
2. EVIDENCE_QUALITY (0.0-1.0): How strong is the supporting evidence?
3. RELEVANCE (0.0-1.0): How relevant to the main debate topic?

Return JSON format:
{{
  "logical_strength": 0.0-1.0,
  "evidence_quality": 0.0-1.0,
  "relevance": 0.0-1.0
}}
"""
        
        try:
            response_text = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=300
            )
            
            # JSON íŒŒì‹±
            import json
            import re
            json_pattern = r'\{.*?\}'
            json_match = re.search(json_pattern, response_text, re.DOTALL)
            
            if json_match:
                scores = json.loads(json_match.group(0))
                return {
                    "logical_strength": scores.get("logical_strength", 0.5),
                    "evidence_quality": scores.get("evidence_quality", 0.5),
                    "relevance": scores.get("relevance", 0.5)
                }
            else:
                # ê¸°ë³¸ ìŠ¤ì½”ì–´
                return {
                    "logical_strength": 0.5,
                    "evidence_quality": 0.5,
                    "relevance": 0.5
                }
                
        except Exception as e:
            logger.error(f"Error getting basic argument scores: {str(e)}")
            return {
                "logical_strength": 0.5,
                "evidence_quality": 0.5,
                "relevance": 0.5
            }
    
    def prepare_attack_strategies_for_speaker(self, target_speaker_id: str) -> List[Dict[str, Any]]:
        """
        íŠ¹ì • ìƒëŒ€ë°©ì— ëŒ€í•œ ê³µê²© ì „ëµë“¤ì„ ì¤€ë¹„
        
        Args:
            target_speaker_id: ê³µê²© ëŒ€ìƒ ë°œì–¸ì ID
            
        Returns:
            ì¤€ë¹„ëœ ê³µê²© ì „ëµ ëª©ë¡
        """
        # ë””ë²„ê¹…: opponent_arguments ìƒíƒœ í™•ì¸
        print(f"   ğŸ” [{self.philosopher_name}] ì „ëµ ì¤€ë¹„ ë””ë²„ê¹…:")
        print(f"      - ëŒ€ìƒ: {target_speaker_id}")
        print(f"      - opponent_arguments í‚¤ë“¤: {list(self.opponent_arguments.keys())}")
        print(f"      - ê° í‚¤ë³„ ë…¼ì§€ ìˆ˜: {[(k, len(v)) for k, v in self.opponent_arguments.items()]}")
        
        if target_speaker_id not in self.opponent_arguments:
            print(f"      âŒ {target_speaker_id}ì— ëŒ€í•œ ë…¼ì§€ê°€ ì—†ìŒ - ì „ëµ ì¤€ë¹„ ë¶ˆê°€")
            return {
                "status": "failed",
                "reason": "no_arguments_found",
                "strategies": [],
                "target_speaker_id": target_speaker_id,
                "strategies_count": 0
            }
        
        try:
            # ìƒëŒ€ë°©ì˜ ì·¨ì•½í•œ ë…¼ì§€ë“¤ ê°€ì ¸ì˜¤ê¸° (ìƒìœ„ 3ê°œ)
            target_arguments = self.opponent_arguments[target_speaker_id]
            print(f"      âœ… {target_speaker_id}ì— ëŒ€í•œ ë…¼ì§€ {len(target_arguments)}ê°œ ë°œê²¬")
            
            vulnerable_args = sorted(target_arguments, 
                                   key=lambda x: x["vulnerability_rank"], 
                                   reverse=True)[:3]
            
            strategies = []
            for arg_data in vulnerable_args:
                argument = arg_data["argument"]
                
                # ì´ ì² í•™ìì—ê²Œ ì í•©í•œ ê³µê²© ì „ëµ ì„ íƒ
                best_strategy = self._select_best_strategy_for_argument(argument)
                
                # êµ¬ì²´ì ì¸ ê³µê²© ê³„íš ìƒì„±
                attack_plan = self._generate_attack_plan(argument, best_strategy)
                
                # RAG ì‚¬ìš© ì—¬ë¶€ íŒë³„
                rag_decision = self._determine_rag_usage_for_strategy(best_strategy)
                
                # RAG ì‚¬ìš©ì´ ê²°ì •ë˜ë©´ ì¿¼ë¦¬ ìƒì„± ë° ê²€ìƒ‰ ìˆ˜í–‰
                if rag_decision["use_rag"]:
                    attack_query = self._generate_attack_rag_query_for_strategy(argument, best_strategy)
                    rag_results = self._perform_attack_rag_search(attack_query, best_strategy)
                    rag_decision["query"] = attack_query
                    rag_decision["results"] = rag_results
                    rag_decision["results_count"] = len(rag_results)
                else:
                    rag_decision["query"] = ""
                    rag_decision["results"] = []
                    rag_decision["results_count"] = 0
                
                strategies.append({
                    "target_argument": argument,
                    "strategy_type": best_strategy,
                    "attack_plan": attack_plan,
                    "vulnerability_score": arg_data["vulnerability_rank"],
                    "priority": len(strategies) + 1,
                    "rag_decision": rag_decision  # RAG íŒë³„ ê²°ê³¼ ì¶”ê°€
                })
            
            # ê³µê²© ì „ëµ ì €ì¥
            self.attack_strategies[target_speaker_id] = strategies
            print(f"      âœ… {len(strategies)}ê°œ ê³µê²© ì „ëµ ì¤€ë¹„ ì™„ë£Œ (RAG íŒë³„ í¬í•¨)")
            
            # RAG ì‚¬ìš© í†µê³„ ì¶œë ¥
            rag_usage_count = sum(1 for s in strategies if s["rag_decision"]["use_rag"])
            print(f"      ğŸ“Š RAG ì‚¬ìš© í†µê³„: {rag_usage_count}/{len(strategies)}ê°œ ì „ëµì—ì„œ RAG ì‚¬ìš©")
            
            return {
                "status": "success",
                "strategies": strategies,
                "target_speaker_id": target_speaker_id,
                "strategies_count": len(strategies),
                "rag_usage_count": rag_usage_count  # RAG ì‚¬ìš© í†µê³„ ì¶”ê°€
            }
            
        except Exception as e:
            logger.error(f"Error preparing attack strategies: {str(e)}")
            print(f"      âŒ ì „ëµ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return {
                "status": "error",
                "error": str(e),
                "strategies": [],
                "target_speaker_id": target_speaker_id,
                "strategies_count": 0
            }
    
    def _select_best_strategy_for_argument(self, argument: Dict[str, Any]) -> str:
        """
        ë…¼ì§€ì— ëŒ€í•´ ì´ ì² í•™ìì—ê²Œ ê°€ì¥ ì í•©í•œ ê³µê²© ì „ëµ ì„ íƒ
        
        Args:
            argument: ê³µê²©í•  ë…¼ì§€
            
        Returns:
            ì„ íƒëœ ì „ëµ ì´ë¦„
        """
        # ì „ëµ ê°€ì¤‘ì¹˜ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
        if not self.strategy_weights:
            return "Clipping"  # ê¸°ë³¸ ì „ëµ
        
        # ë…¼ì§€ ìœ í˜•ì— ë”°ë¥¸ ì „ëµ ì í•©ì„± ë¶„ì„
        argument_type = argument.get("argument_type", "logical")
        claim = argument.get("claim", "")
        
        # ê° ì „ëµì˜ ì í•©ì„± ì ìˆ˜ ê³„ì‚°
        strategy_scores = {}
        
        for strategy, weight in self.strategy_weights.items():
            base_score = weight
            
            # ë…¼ì§€ ìœ í˜•ë³„ ë³´ì •
            if strategy == "Clipping" and "specific" in claim.lower():
                base_score *= 1.2
            elif strategy == "Framing Shift" and "assume" in claim.lower():
                base_score *= 1.3
            elif strategy == "Reductive Paradox" and argument_type == "logical":
                base_score *= 1.1
            elif strategy == "Conceptual Undermining" and any(word in claim.lower() for word in ["define", "mean", "is"]):
                base_score *= 1.4
            elif strategy == "Ethical Reversal" and argument_type == "emotional":
                base_score *= 1.2
            
            strategy_scores[strategy] = base_score
        
        # ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ ì „ëµ ì„ íƒ
        best_strategy = max(strategy_scores.items(), key=lambda x: x[1])[0]
        return best_strategy
    
    def _generate_attack_plan(self, target_argument: Dict[str, Any], strategy_type: str) -> Dict[str, Any]:
        """
        íŠ¹ì • ì „ëµì„ ì‚¬ìš©í•œ êµ¬ì²´ì ì¸ ê³µê²© ê³„íš ìƒì„±
        
        Args:
            target_argument: ê³µê²©í•  ë…¼ì§€
            strategy_type: ì‚¬ìš©í•  ì „ëµ ìœ í˜•
            
        Returns:
            êµ¬ì²´ì ì¸ ê³µê²© ê³„íš
        """
        try:
            # ì´ë¯¸ ë¡œë“œëœ ì „ëµ ì •ë³´ ì‚¬ìš©
            strategy_info = self.strategy_styles.get(strategy_type, {})
            
            system_prompt = f"""
You are {self.philosopher_name}, a philosopher with this essence: {self.philosopher_essence}
Your debate style: {self.philosopher_debate_style}
Your personality: {self.philosopher_personality}

You need to prepare an attack against an opponent's argument using the "{strategy_type}" strategy.
"""

            user_prompt = f"""
STRATEGY: {strategy_type}
DESCRIPTION: {strategy_info.get('description', '')}
STYLE PROMPT: {strategy_info.get('style_prompt', '')}
EXAMPLE: {strategy_info.get('example', '')}

TARGET ARGUMENT TO ATTACK:
- Claim: {target_argument.get('claim', '')}
- Evidence: {target_argument.get('evidence', '')}
- Reasoning: {target_argument.get('reasoning', '')}
- Assumptions: {target_argument.get('assumptions', [])}

Create a specific attack plan using this strategy. Include:
1. The exact point you will target
2. How you will apply the {strategy_type} strategy
3. The key phrase or question you will use
4. Expected counterargument and your response

Return JSON format:
{{
  "target_point": "specific point to attack",
  "strategy_application": "how to apply {strategy_type}",
  "key_phrase": "main attack phrase/question",
  "expected_counter": "likely opponent response",
  "follow_up": "your follow-up response"
}}
"""
            
            response_text = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=800
            )
            
            # JSON íŒŒì‹±
            import re
            json_pattern = r'\{.*?\}'
            json_match = re.search(json_pattern, response_text, re.DOTALL)
            
            if json_match:
                attack_plan = json.loads(json_match.group(0))
                return attack_plan
            else:
                # ê¸°ë³¸ ê³µê²© ê³„íš
                return {
                    "target_point": target_argument.get('claim', ''),
                    "strategy_application": f"Apply {strategy_type}",
                    "key_phrase": strategy_info.get('style_prompt', ''),
                    "expected_counter": "Opponent may defend",
                    "follow_up": "Continue with philosophical reasoning"
                }
                
        except Exception as e:
            logger.error(f"Error generating attack plan: {str(e)}")
            return {
                "target_point": target_argument.get('claim', ''),
                "strategy_application": f"Use {strategy_type}",
                "key_phrase": "Challenge this point",
                "expected_counter": "Unknown",
                "follow_up": "Continue debate"
            }
    
    def get_best_attack_strategy(self, target_speaker_id: str, context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        í˜„ì¬ ìƒí™©ì—ì„œ ìµœì ì˜ ê³µê²© ì „ëµ ì„ íƒ
        
        Args:
            target_speaker_id: ê³µê²© ëŒ€ìƒ ID
            context: í˜„ì¬ í† ë¡  ë§¥ë½
            
        Returns:
            ì„ íƒëœ ìµœì  ê³µê²© ì „ëµ
        """
        if target_speaker_id not in self.attack_strategies:
            return None
        
        strategies = self.attack_strategies[target_speaker_id]
        if not strategies:
            return None
        
        # í˜„ì¬ í† ë¡  ë‹¨ê³„ì™€ ë§¥ë½ì„ ê³ ë ¤í•˜ì—¬ ìµœì  ì „ëµ ì„ íƒ
        current_stage = context.get("current_stage", "")
        recent_messages = context.get("recent_messages", [])
        
        # ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ì „ëµ ì„ íƒ (ì·¨ì•½ì„± ê¸°ì¤€)
        best_strategy = max(strategies, key=lambda x: x["vulnerability_score"])
        
        return best_strategy
    
    def clear_opponent_data(self, speaker_id: str = None):
        """
        ìƒëŒ€ë°© ë°ì´í„° ì´ˆê¸°í™” (ìƒˆ í† ë¡  ì‹œì‘ ì‹œ)
        
        Args:
            speaker_id: íŠ¹ì • ë°œì–¸ìë§Œ ì´ˆê¸°í™”í•  ê²½ìš°
        """
        if speaker_id:
            self.opponent_arguments.pop(speaker_id, None)
            self.attack_strategies.pop(speaker_id, None)
        else:
            self.opponent_arguments.clear()
            self.attack_strategies.clear()
            self.argument_scores.clear() 
    
    def _prepare_argument(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        ì…ë¡  ì¤€ë¹„ ì²˜ë¦¬
        
        Args:
            input_data: ì…ë¡  ì¤€ë¹„ì— í•„ìš”í•œ ë°ì´í„°
            
        Returns:
            ì¤€ë¹„ ê²°ê³¼
        """
        topic = input_data.get("topic", "")
        stance_statement = input_data.get("stance_statement", "")
        context = input_data.get("context", {})
        
        self.prepare_argument_with_rag(topic, stance_statement, context)
        
        return {
            "status": "success" if self.argument_prepared else "failed",
            "prepared": self.argument_prepared,
            "core_arguments_count": len(self.core_arguments),
            "queries_count": len(self.argument_queries)
        }
    
    def _generate_attack_rag_query_for_strategy(self, target_argument: Dict[str, Any], strategy_type: str) -> str:
        """
        íŠ¹ì • ë…¼ì§€ë¥¼ íŠ¹ì • ì „ëµìœ¼ë¡œ ê³µê²©í•˜ê¸° ìœ„í•œ RAG ì¿¼ë¦¬ ìƒì„± (ê°„ì†Œí™”ëœ ë²„ì „)
        
        Args:
            target_argument: ê³µê²©í•  ìƒëŒ€ë°© ë…¼ì§€
            strategy_type: ì‚¬ìš©í•  ê³µê²© ì „ëµ
            
        Returns:
            RAG ê²€ìƒ‰ìš© ì¿¼ë¦¬ ë¬¸ìì—´
        """
        print(f"   ğŸ” [{self.philosopher_name}] ê³µê²©ìš© RAG ì¿¼ë¦¬ ìƒì„±:")
        print(f"      ğŸ¯ ì „ëµ: {strategy_type}")
        print(f"      ğŸ“ ëŒ€ìƒ ë…¼ì§€: {target_argument.get('claim', '')[:80]}...")
        
        try:
            # ê°„ì†Œí™”ëœ í”„ë¡¬í”„íŠ¸
            system_prompt = """Generate academic search queries for debate attacks. Focus on finding concrete evidence, statistics, and research data."""

            # ì „ëµë³„ í‚¤ì›Œë“œ ë§¤í•‘ (ê°„ë‹¨í™”)
            strategy_keywords = {
                "Clipping": "empirical evidence contradicting",
                "Framing Shift": "alternative theoretical frameworks", 
                "Reductive Paradox": "unintended consequences case studies",
                "Conceptual Undermining": "definitional problems conceptual analysis",
                "Ethical Reversal": "ethical implications moral philosophy",
                "Temporal Delay": "long-term effects historical analysis",
                "Philosophical Reframing": "philosophical critique theoretical foundations"
            }
            
            strategy_prefix = strategy_keywords.get(strategy_type, "academic research on")
            claim_keywords = self._extract_key_concept(target_argument.get('claim', ''))
            
            user_prompt = f"""
ATTACK: {target_argument.get('claim', '')[:100]}
STRATEGY: {strategy_type}
PHILOSOPHER: {self.philosopher_name}

Generate ONE academic search query (max 10 words) to find concrete evidence/statistics to attack this claim using {strategy_type}.

Format: "{strategy_prefix} [specific topic keywords]"
Focus on: statistics, research data, case studies, empirical evidence

Query:"""
            
            response = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=1500  # ì›ë˜ëŒ€ë¡œ ë³µì›
            )
            
            # ì¿¼ë¦¬ ì •ë¦¬
            query = response.strip().strip('"').strip("'")
            if len(query.split()) > 10:
                query = ' '.join(query.split()[:10])
            
            # ê¸°ë³¸ í‚¤ì›Œë“œê°€ ì—†ìœ¼ë©´ ì¶”ê°€
            if not any(keyword in query.lower() for keyword in ['evidence', 'research', 'study', 'data', 'statistics']):
                query = f"{strategy_prefix} {claim_keywords}"
            
            print(f"      âœ… ìƒì„±ëœ ì¿¼ë¦¬: '{query}'")
            return query
            
        except Exception as e:
            logger.error(f"Error generating attack RAG query: {str(e)}")
            print(f"      âŒ ì¿¼ë¦¬ ìƒì„± ì‹¤íŒ¨: {str(e)}")
            
            # ê°„ì†Œí™”ëœ fallback
            strategy_keywords = {
                "Clipping": "empirical evidence contradicting",
                "Framing Shift": "alternative frameworks",
                "Reductive Paradox": "unintended consequences",
                "Conceptual Undermining": "definitional problems",
                "Ethical Reversal": "ethical implications",
                "Temporal Delay": "long-term effects",
                "Philosophical Reframing": "philosophical critique"
            }
            
            prefix = strategy_keywords.get(strategy_type, "research on")
            concept = self._extract_key_concept(target_argument.get('claim', ''))
            fallback_query = f"{prefix} {concept}"
            
            print(f"      ğŸ”„ ê°„ì†Œí™”ëœ ê¸°ë³¸ ì¿¼ë¦¬ ì‚¬ìš©: '{fallback_query}'")
            return fallback_query
    
    def _extract_key_concept(self, text: str) -> str:
        """
        í…ìŠ¤íŠ¸ì—ì„œ í•µì‹¬ ê°œë… ì¶”ì¶œ (3-4 ë‹¨ì–´ë¡œ ì œí•œ)
        
        Args:
            text: ì›ë³¸ í…ìŠ¤íŠ¸
            
        Returns:
            í•µì‹¬ ê°œë… (3-4 ë‹¨ì–´)
        """
        if not text:
            return "social development"
        
        # ë¶ˆìš©ì–´ ì œê±° ë° í•µì‹¬ ê°œë… ì¶”ì¶œ
        import re
        
        # ê¸°ë³¸ ì •ë¦¬
        clean_text = re.sub(r'[^\w\s]', ' ', text.lower())
        words = clean_text.split()
        
        # ë¶ˆìš©ì–´ ëª©ë¡
        stop_words = {
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 
            'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
            'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
            'should', 'may', 'might', 'can', 'must', 'shall', 'this', 'that',
            'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'
        }
        
        # ì˜ë¯¸ìˆëŠ” ë‹¨ì–´ë§Œ ì¶”ì¶œ
        meaningful_words = [word for word in words if word not in stop_words and len(word) > 2]
        
        # ìƒìœ„ 3-4ê°œ ë‹¨ì–´ ì„ íƒ
        key_concept = ' '.join(meaningful_words[:4])
        
        return key_concept if key_concept else "social development"
    
    def _perform_attack_rag_search(self, query: str, strategy_type: str) -> List[Dict[str, Any]]:
        """
        ê³µê²©ìš© RAG ê²€ìƒ‰ ìˆ˜í–‰ (ê°œì„ ëœ ë²„ì „ - ê´€ë ¨ì„± í‰ê°€ ë° í•„í„°ë§ í¬í•¨)
        
        Args:
            query: ê²€ìƒ‰ ì¿¼ë¦¬
            strategy_type: ê³µê²© ì „ëµ (ë¡œê¹…ìš©)
            
        Returns:
            ê²€ìƒ‰ ê²°ê³¼ ëª©ë¡ (ê´€ë ¨ì„± ìˆœìœ¼ë¡œ ì •ë ¬ë¨)
        """
        print(f"   ğŸ” [{self.philosopher_name}] ê³µê²©ìš© RAG ê²€ìƒ‰:")
        print(f"      ğŸ¯ ì „ëµ: {strategy_type}")
        print(f"      ğŸ” ì¿¼ë¦¬: '{query}'")
        
        try:
            # 1. ë‹¤ì–‘í•œ ì†ŒìŠ¤ì—ì„œ ê²€ìƒ‰ ìˆ˜í–‰
            all_results = []
            
            # ì›¹ ê²€ìƒ‰ (ê¸°ë³¸)
            web_results = self._web_search(query)
            all_results.extend(web_results)
            
            # ë²¡í„° ê²€ìƒ‰ (ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸)
            if len(all_results) < 5:
                vector_results = self._vector_search(query)
                all_results.extend(vector_results)
            
            # ì² í•™ì ì „ë¬¸ ê²€ìƒ‰ (ì² í•™ì  ë‚´ìš©)
            if len(all_results) < 5:
                philosopher_results = self._philosopher_search(query)
                all_results.extend(philosopher_results)
            
            print(f"      ğŸ“Š ì›ë³¸ ê²€ìƒ‰ ê²°ê³¼: {len(all_results)}ê°œ")
            
            # 2. ê²€ìƒ‰ ê²°ê³¼ ê´€ë ¨ì„± í‰ê°€ ë° í•„í„°ë§
            if all_results:
                filtered_results = self._filter_and_rank_search_results(all_results, query, strategy_type)
                print(f"      âœ… í•„í„°ë§ í›„: {len(filtered_results)}ê°œ ê³ í’ˆì§ˆ ê²°ê³¼")
                
                for i, result in enumerate(filtered_results, 1):
                    title = result.get('title', 'No title')[:50]
                    relevance = result.get('relevance_score', 0.0)
                    url = result.get('url', result.get('link', result.get('href', '')))
                    print(f"         {i}. {title}... (ê´€ë ¨ì„±: {relevance:.2f})")
                    if url:
                        print(f"            ğŸ”— URL: {url}")
                    else:
                        print(f"            ğŸ”— URL: ì—†ìŒ")
                
                return filtered_results
            else:
                print(f"      âŒ ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ")
                return []
            
        except Exception as e:
            logger.error(f"Error in attack RAG search: {str(e)}")
            print(f"      âŒ ê²€ìƒ‰ ì‹¤íŒ¨: {str(e)}")
            return []
    
    def _filter_and_rank_search_results(self, results: List[Dict[str, Any]], query: str, strategy_type: str) -> List[Dict[str, Any]]:
        """
        ê²€ìƒ‰ ê²°ê³¼ë¥¼ ê´€ë ¨ì„±ì— ë”°ë¼ í•„í„°ë§í•˜ê³  ìˆœìœ„ë¥¼ ë§¤ê¹€
        
        Args:
            results: ì›ë³¸ ê²€ìƒ‰ ê²°ê³¼
            query: ê²€ìƒ‰ ì¿¼ë¦¬
            strategy_type: ê³µê²© ì „ëµ
            
        Returns:
            í•„í„°ë§ë˜ê³  ìˆœìœ„ê°€ ë§¤ê²¨ì§„ ê²°ê³¼ (ìƒìœ„ 3ê°œ)
        """
        if not results:
            return []
        
        print(f"      ğŸ” ê²€ìƒ‰ ê²°ê³¼ ê´€ë ¨ì„± í‰ê°€ ì¤‘...")
        
        # ê° ê²°ê³¼ì— ëŒ€í•´ ê´€ë ¨ì„± ì ìˆ˜ ê³„ì‚°
        scored_results = []
        
        for result in results:
            try:
                relevance_score = self._calculate_result_relevance(result, query, strategy_type)
                
                # ìµœì†Œ ê´€ë ¨ì„± ì„ê³„ê°’ (0.3 ì´ìƒë§Œ ìœ ì§€)
                if relevance_score >= 0.3:
                    result['relevance_score'] = relevance_score
                    scored_results.append(result)
                    
            except Exception as e:
                logger.warning(f"Error scoring result: {str(e)}")
                # ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ì ìˆ˜ ë¶€ì—¬
                result['relevance_score'] = 0.5
                scored_results.append(result)
        
        # ê´€ë ¨ì„± ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
        scored_results.sort(key=lambda x: x.get('relevance_score', 0), reverse=True)
        
        # ìƒìœ„ 3ê°œë§Œ ë°˜í™˜
        return scored_results[:3]
    
    def _calculate_result_relevance(self, result: Dict[str, Any], query: str, strategy_type: str) -> float:
        """
        ê°œë³„ ê²€ìƒ‰ ê²°ê³¼ì˜ ê´€ë ¨ì„± ì ìˆ˜ ê³„ì‚°
        
        Args:
            result: ê²€ìƒ‰ ê²°ê³¼
            query: ê²€ìƒ‰ ì¿¼ë¦¬
            strategy_type: ê³µê²© ì „ëµ
            
        Returns:
            ê´€ë ¨ì„± ì ìˆ˜ (0.0-1.0)
        """
        title = result.get('title', '').lower()
        content = result.get('content', result.get('snippet', '')).lower()
        combined_text = f"{title} {content}"
        
        if not combined_text.strip():
            return 0.0
        
        relevance_score = 0.0
        
        # 1. ì¿¼ë¦¬ í‚¤ì›Œë“œ ë§¤ì¹­ (40%)
        query_words = set(query.lower().split())
        text_words = set(combined_text.split())
        keyword_overlap = len(query_words.intersection(text_words)) / len(query_words) if query_words else 0
        relevance_score += keyword_overlap * 0.4
        
        # 2. í•™ìˆ ì  í’ˆì§ˆ ì§€í‘œ (30%)
        academic_indicators = [
            'research', 'study', 'analysis', 'theory', 'evidence', 'empirical',
            'journal', 'university', 'professor', 'scholar', 'academic',
            'peer-reviewed', 'published', 'findings', 'methodology', 'data'
        ]
        academic_score = sum(1 for indicator in academic_indicators if indicator in combined_text)
        academic_score = min(academic_score / 5, 1.0)  # ì •ê·œí™” (ìµœëŒ€ 5ê°œ ì§€í‘œ)
        relevance_score += academic_score * 0.3
        
        # 3. ì „ëµë³„ íŠ¹í™” í‚¤ì›Œë“œ (20%)
        strategy_keywords = {
            "Clipping": ['evidence', 'contradicts', 'disproves', 'refutes', 'counter', 'against'],
            "Framing Shift": ['alternative', 'perspective', 'framework', 'approach', 'different', 'reframe'],
            "Reductive Paradox": ['consequences', 'extreme', 'unintended', 'problems', 'issues', 'risks'],
            "Conceptual Undermining": ['definition', 'concept', 'meaning', 'unclear', 'ambiguous', 'problematic'],
            "Ethical Reversal": ['ethics', 'moral', 'ethical', 'wrong', 'harmful', 'concerns'],
            "Temporal Delay": ['long-term', 'future', 'later', 'eventually', 'time', 'delayed'],
            "Philosophical Reframing": ['philosophy', 'philosophical', 'fundamental', 'deeper', 'underlying', 'essence']
        }
        
        strategy_words = strategy_keywords.get(strategy_type, [])
        strategy_score = sum(1 for word in strategy_words if word in combined_text)
        strategy_score = min(strategy_score / 3, 1.0)  # ì •ê·œí™” (ìµœëŒ€ 3ê°œ í‚¤ì›Œë“œ)
        relevance_score += strategy_score * 0.2
        
        # 4. ì² í•™ìë³„ ê´€ì‹¬ ë¶„ì•¼ (10%)
        philosopher_keywords = self._get_philosopher_domain_keywords()
        philosopher_score = sum(1 for keyword in philosopher_keywords if keyword in combined_text)
        philosopher_score = min(philosopher_score / 3, 1.0)  # ì •ê·œí™”
        relevance_score += philosopher_score * 0.1
        
        # ìµœì¢… ì ìˆ˜ ì •ê·œí™” (0.0-1.0)
        return min(relevance_score, 1.0)
    
    def _get_philosopher_domain_keywords(self) -> List[str]:
        """
        í˜„ì¬ ì² í•™ìì˜ ì „ë¬¸ ë¶„ì•¼ í‚¤ì›Œë“œ ë°˜í™˜
        
        Returns:
            ì² í•™ìë³„ ë„ë©”ì¸ í‚¤ì›Œë“œ ëª©ë¡
        """
        philosopher_domains = {
            "marx": ['class', 'capitalism', 'labor', 'economic', 'social', 'collective', 'workers', 'society'],
            "nietzsche": ['individual', 'power', 'will', 'strength', 'elite', 'superior', 'genius', 'creativity'],
            "kant": ['duty', 'moral', 'categorical', 'imperative', 'rational', 'universal', 'ethics', 'reason'],
            "aristotle": ['virtue', 'ethics', 'practical', 'wisdom', 'character', 'excellence', 'good', 'flourishing'],
            "plato": ['ideal', 'forms', 'justice', 'truth', 'knowledge', 'reality', 'philosopher', 'wisdom'],
            "socrates": ['knowledge', 'wisdom', 'questioning', 'examined', 'life', 'virtue', 'ignorance', 'truth'],
            "hegel": ['dialectic', 'spirit', 'history', 'absolute', 'consciousness', 'development', 'synthesis'],
            "camus": ['absurd', 'meaning', 'existence', 'revolt', 'freedom', 'authentic', 'human', 'condition']
        }
        
        philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
        return philosopher_domains.get(philosopher_key, ['philosophy', 'thought', 'theory', 'concept'])
    
    def _format_attack_rag_results(self, rag_results: List[Dict[str, Any]], strategy_type: str) -> str:
        """
        ê³µê²©ìš© RAG ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì „ëµì— ë§ê²Œ í¬ë§·íŒ…
        
        Args:
            rag_results: RAG ê²€ìƒ‰ ê²°ê³¼
            strategy_type: ê³µê²© ì „ëµ
            
        Returns:
            í¬ë§·íŒ…ëœ RAG ì •ë³´ ë¬¸ìì—´
        """
        if not rag_results:
            return ""
        
        # ì „ëµë³„ í¬ë§·íŒ… ì ‘ë‘ì‚¬
        strategy_prefixes = {
            "Clipping": "COUNTER-EVIDENCE",
            "Framing Shift": "ALTERNATIVE PERSPECTIVES", 
            "Reductive Paradox": "EXTREME CASES & CONSEQUENCES",
            "Conceptual Undermining": "DEFINITIONAL ISSUES",
            "Ethical Reversal": "ETHICAL CONCERNS",
            "Temporal Delay": "LONG-TERM RISKS",
            "Philosophical Reframing": "PHILOSOPHICAL CRITIQUES"
        }
        
        prefix = strategy_prefixes.get(strategy_type, "SUPPORTING EVIDENCE")
        
        formatted_results = f"\n{prefix} (use strategically):\n"
        
        for i, result in enumerate(rag_results[:3], 1):  # ìµœëŒ€ 3ê°œ ì‚¬ìš© (2ê°œâ†’3ê°œ)
            title = result.get('title', 'Source')
            content = result.get('content', result.get('snippet', ''))
            
            # ë‚´ìš©ì„ í†µì§¸ë¡œ ì‚¬ìš© (100ì ì œí•œ ì œê±°)
            formatted_results += f"{i}. {title}: {content}\n"
        
        return formatted_results
    
    def _generate_followup_response(self, topic: str, recent_messages: List[Dict[str, Any]], dialogue_state: Dict[str, Any], stance_statements: Dict[str, str], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            dialogue_state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
            stance_statements: ì°¬ë°˜ ì…ì¥ ì§„ìˆ ë¬¸
            emotion_enhancement: ê°ì • ê°•í™” ë°ì´í„° (ì„ íƒì )
            
        Returns:
            ìƒì„±ëœ íŒ”ë¡œìš°ì—… ì‘ë‹µ
        """
        print(f"ğŸ”„ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„± ì‹œì‘")
        
        # 1. ìƒëŒ€ë°© ë°©ì–´ ì‘ë‹µ ë¶„ì„
        defense_info = self._analyze_defense_response(recent_messages)
        
        # 2. íŒ”ë¡œìš°ì—… ì „ëµ ì„ íƒ
        followup_strategy = self._select_followup_strategy(defense_info, emotion_enhancement)
        
        # 3. íŒ”ë¡œìš°ì—…ìš© RAG ì‚¬ìš© ì—¬ë¶€ ê²°ì •
        followup_rag_decision = self._determine_followup_rag_usage(followup_strategy, defense_info)
        
        # 4. íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„±
        followup_response = self._generate_followup_response_with_strategy(
            topic, recent_messages, stance_statements, followup_strategy, 
            followup_rag_decision, emotion_enhancement
        )
        
        # 5. íŒ”ë¡œìš°ì—… ì „ëµ ì •ë³´ ì €ì¥
        try:
            if not hasattr(self, 'followup_strategies'):
                self.followup_strategies = []
                
            defense_info_summary = {
                "defense_strategy": defense_info.get("defense_strategy", "Unknown"),
                "rag_used": defense_info.get("rag_used", False),
                "defender_id": defense_info.get("defender_id", "unknown")
            }
            
            # íŒ”ë¡œìš°ì—… ì •ë³´ ì €ì¥
            self.followup_strategies.append({
                "timestamp": datetime.now().isoformat(),
                "followup_strategy": followup_strategy,
                "rag_decision": followup_rag_decision,
                "followup_plan": {
                    "defense_info": defense_info_summary,
                    "selected_strategy": followup_strategy,
                    "emotion_state": emotion_enhancement.get("emotion_type", "neutral") if emotion_enhancement else "neutral",
                    "source": "followup_system"
                }
            })
            
            # íŒ”ë¡œìš°ì—… ì „ëµ ì •ë³´ë¥¼ í´ë˜ìŠ¤ ë ˆë²¨ì— ì €ì¥ (ë‹¤ë¥¸ ì—ì´ì „íŠ¸ê°€ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡)
            self.last_followup_strategy = {
                "followup_strategy": followup_strategy,
                "rag_decision": followup_rag_decision,
                "followup_plan": {
                    "defense_info": defense_info_summary,
                    "emotion_state": emotion_enhancement.get("emotion_type", "neutral") if emotion_enhancement else "neutral"
                }
            }
            
            print(f"ğŸ”„ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì •ë³´ ì €ì¥ ì™„ë£Œ")
        except Exception as e:
            logger.error(f"Error storing followup strategy info: {str(e)}")
            print(f"âŒ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì •ë³´ ì €ì¥ ì˜¤ë¥˜: {str(e)}")
        
        print(f"ğŸ”„ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„± ì™„ë£Œ")
        return followup_response
    
    def _analyze_defense_response(self, recent_messages: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        ìƒëŒ€ë°©ì˜ ë°©ì–´ ì‘ë‹µ ë¶„ì„
        
        Args:
            recent_messages: ìµœê·¼ ë©”ì‹œì§€ ëª©ë¡
            
        Returns:
            ë°©ì–´ ì‘ë‹µ ë¶„ì„ ê²°ê³¼
        """
        if not recent_messages:
            return {"defense_strategy": "Unknown", "rag_used": False, "defender_id": "unknown"}
        
        last_message = recent_messages[-1]
        defender_id = last_message.get('speaker_id', 'unknown')
        defense_text = last_message.get('text', '')
        
        print(f"   ğŸ” [{self.philosopher_name}] ë°©ì–´ ì‘ë‹µ ë¶„ì„:")
        print(f"      ğŸ‘¤ ë°©ì–´ì: {defender_id}")
        
        # ë°©ì–´ì ì—ì´ì „íŠ¸ì˜ ì‹¤ì œ ë°©ì–´ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ê°€ëŠ¥í•˜ë©´)
        defense_info = self._get_defender_strategy_info(defender_id)
        
        if defense_info["defense_strategy"] != "Unknown":
            print(f"      âœ… ì‹¤ì œ ë°©ì–´ ì „ëµ ë°œê²¬: {defense_info['defense_strategy']}")
            print(f"      ğŸ“š ë°©ì–´ RAG ì‚¬ìš©: {defense_info['rag_used']}")
        else:
            print(f"      âŒ ë°©ì–´ ì „ëµ ì •ë³´ ì—†ìŒ - í‚¤ì›Œë“œ ì¶”ì • ì‚¬ìš©")
            # Fallback: í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì •
            defense_info = self._estimate_defense_strategy_from_keywords(defense_text, defender_id)
        
        defense_info["defender_id"] = defender_id
        defense_info["defense_text"] = defense_text[:200]  # ë¶„ì„ìš© ì¼ë¶€ í…ìŠ¤íŠ¸
        
        return defense_info
    
    def _get_defender_strategy_info(self, defender_id: str) -> Dict[str, Any]:
        """
        ë°©ì–´ì ì—ì´ì „íŠ¸ì˜ ì‹¤ì œ ì‚¬ìš©í•œ ë°©ì–´ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        ê³µê²©ì ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ëŠ” ë¡œì§ê³¼ ë™ì¼í•˜ê²Œ ì‘ë™
        
        Args:
            defender_id: ë°©ì–´ì ì—ì´ì „íŠ¸ ID
            
        Returns:
            ë°©ì–´ ì „ëµ ì •ë³´
        """
        try:
            print(f"      ğŸ‘¤ ë°©ì–´ì: {defender_id}")
            
            # ë°©ì–´ì ì—ì´ì „íŠ¸ ì°¸ì¡° ê°€ì ¸ì˜¤ê¸° (ê³µê²©ì ì°¸ì¡° ê°€ì ¸ì˜¤ê¸° ë¡œì§ ì¬ì‚¬ìš©)
            defender_agent = self._get_attacker_agent_reference(defender_id)
            
            if defender_agent is None:
                print(f"         âŒ ë°©ì–´ì ì—ì´ì „íŠ¸ ì°¸ì¡° ì—†ìŒ")
                # í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì •ìœ¼ë¡œ í´ë°± 
                return self._estimate_defense_strategy_from_recent_messages(defender_id)
            
            # ë°©ì–´ìì˜ ìµœê·¼ ì‚¬ìš©í•œ ë°©ì–´ ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            recent_defense_strategy = self._get_recent_defense_strategy(defender_agent)
            
            if recent_defense_strategy:
                strategy_type = recent_defense_strategy.get('strategy_type', 'Unknown')
                rag_decision = recent_defense_strategy.get('rag_decision', {})
                rag_used = rag_decision.get('use_rag', False)
                
                print(f"         âœ… ë°©ì–´ì ì „ëµ ì •ë³´:")
                print(f"            ğŸ›¡ï¸ ì „ëµ: {strategy_type}")
                print(f"            ğŸ“š RAG: {rag_used}")
                
                return {
                    "defense_strategy": strategy_type,
                    "rag_used": rag_used,
                    "defense_plan": recent_defense_strategy.get('defense_plan', {}),
                    "source": "actual_defender_data"
                }
            else:
                print(f"         âŒ ë°©ì–´ìì˜ ìµœê·¼ ì „ëµ ì •ë³´ ì—†ìŒ")
                # í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì •ìœ¼ë¡œ í´ë°±
                return self._estimate_defense_strategy_from_recent_messages(defender_id)
                
        except Exception as e:
            logger.error(f"Error getting defender strategy info: {str(e)}")
            print(f"         âŒ ë°©ì–´ì ì „ëµ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
            return {"defense_strategy": "Unknown", "rag_used": False}
    
    def _estimate_defense_strategy_from_recent_messages(self, defender_id: str) -> Dict[str, Any]:
        """
        ìµœê·¼ ë©”ì‹œì§€ì—ì„œ ë°©ì–´ìì˜ ë°©ì–´ ì „ëµ ì¶”ì •
        
        Args:
            defender_id: ë°©ì–´ì ID
            
        Returns:
            ì¶”ì •ëœ ë°©ì–´ ì „ëµ ì •ë³´
        """
        try:
            # _current_dialogue_stateê°€ ìˆìœ¼ë©´ ì‚¬ìš© (generate_responseì—ì„œ ì €ì¥)
            if hasattr(self, '_current_dialogue_state'):
                dialogue_state = self._current_dialogue_state
                speaking_history = dialogue_state.get('speaking_history', [])
                
                # ë°©ì–´ìì˜ ìµœê·¼ ë°©ì–´ ë©”ì‹œì§€ ì°¾ê¸°
                defense_messages = []
                for msg in reversed(speaking_history):
                    if (msg.get('speaker_id') == defender_id and 
                        msg.get('stage') == 'interactive_argument'):
                        defense_messages.append(msg)
                        if len(defense_messages) >= 1:  # ìµœê·¼ 1ê°œë§Œ
                            break
                
                if defense_messages:
                    defense_text = defense_messages[0].get('text', '')
                    print(f"         ğŸ”„ í‚¤ì›Œë“œ ê¸°ë°˜ ë°©ì–´ ì „ëµ ì¶”ì • ì‹œì‘")
                    
                    return self._estimate_defense_strategy_from_keywords(defense_text, defender_id)
            
            print(f"         âŒ ë°©ì–´ìì˜ ìµœê·¼ ë©”ì‹œì§€ ì—†ìŒ")
            return {"defense_strategy": "Unknown", "rag_used": False}
            
        except Exception as e:
            logger.error(f"Error estimating defense strategy from recent messages: {str(e)}")
            return {"defense_strategy": "Unknown", "rag_used": False}
    
    def _estimate_defense_strategy_from_keywords(self, defense_text: str, defender_id: str) -> Dict[str, Any]:
        """
        í‚¤ì›Œë“œ ê¸°ë°˜ ë°©ì–´ ì „ëµ ì¶”ì • (Fallback ë°©ë²•)
        
        Args:
            defense_text: ë°©ì–´ í…ìŠ¤íŠ¸
            defender_id: ë°©ì–´ì ID
            
        Returns:
            ì¶”ì •ëœ ë°©ì–´ ì •ë³´
        """
        defense_text_lower = defense_text.lower()
        
        print(f"         ğŸ”„ í‚¤ì›Œë“œ ê¸°ë°˜ ë°©ì–´ ì „ëµ ì¶”ì • ì‹œì‘")
        
        # ë°©ì–´ ì „ëµ ì¶”ì • (í‚¤ì›Œë“œ ê¸°ë°˜)
        defense_strategy = "Unknown"
        if any(word in defense_text_lower for word in ['wrong', 'incorrect', 'false', 'disagree']):
            defense_strategy = "Refute"
        elif any(word in defense_text_lower for word in ['clarify', 'explain', 'mean', 'actually']):
            defense_strategy = "Clarify"
        elif any(word in defense_text_lower for word in ['agree', 'true', 'valid', 'point']):
            defense_strategy = "Accept"
        elif any(word in defense_text_lower for word in ['different', 'perspective', 'rather', 'instead']):
            defense_strategy = "Reframe"
        elif any(word in defense_text_lower for word in ['question', 'challenge', 'back', 'ask']):
            defense_strategy = "Counter-Challenge"
        elif any(word in defense_text_lower for word in ['both', 'combine', 'integrate', 'together']):
            defense_strategy = "Synthesis"
        
        # RAG ì‚¬ìš© ì—¬ë¶€ ì¶”ì • (êµ¬ì²´ì  ë°ì´í„°/ì¸ìš© ìˆìœ¼ë©´ RAG ì‚¬ìš©ìœ¼ë¡œ ì¶”ì •)
        rag_used = any(indicator in defense_text_lower for indicator in [
            'study', 'research', 'data', 'statistics', 'according to', 'evidence', 'findings'
        ])
        
        print(f"         ğŸ“Š ì¶”ì • ê²°ê³¼: {defense_strategy} (RAG: {rag_used})")
        
        return {
            "defense_strategy": defense_strategy,
            "rag_used": rag_used,
            "source": "keyword_estimation"
        }
    
    def _select_followup_strategy(self, defense_info: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        íŒ”ë¡œìš°ì—… ì „ëµ ì„ íƒ
        
        Args:
            defense_info: ë°©ì–´ ì •ë³´
            emotion_enhancement: ê°ì • ê°•í™” ì •ë³´
            
        Returns:
            ì„ íƒëœ íŒ”ë¡œìš°ì—… ì „ëµëª…
        """
        print(f"   ğŸ”„ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì „ëµ ì„ íƒ ì‹œì‘")
        
        try:
            # 1. followup_map.yamlì—ì„œ í›„ë³´ ì „ëµ ê°€ì ¸ì˜¤ê¸°
            followup_candidates = self._get_followup_candidates_from_map(defense_info, emotion_enhancement)
            
            if not followup_candidates:
                print(f"   âŒ íŒ”ë¡œìš°ì—… í›„ë³´ ì „ëµ ì—†ìŒ - ê¸°ë³¸ FollowUpQuestion ì‚¬ìš©")
                return "FollowUpQuestion"
            
            print(f"   ğŸ“‹ í›„ë³´ ì „ëµë“¤: {followup_candidates}")
            
            # 2. ì² í•™ìì˜ followup_weights ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            followup_weights = philosopher_data.get("followup_weights", {})
            
            if not followup_weights:
                print(f"   âŒ ì² í•™ì íŒ”ë¡œìš°ì—… ê°€ì¤‘ì¹˜ ì—†ìŒ - ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©")
                return followup_candidates[0]
            
            print(f"   âš–ï¸ ì² í•™ì íŒ”ë¡œìš°ì—… ê°€ì¤‘ì¹˜: {followup_weights}")
            
            # 3. í›„ë³´ ì „ëµë“¤ì— ëŒ€í•œ ê°€ì¤‘ì¹˜ë§Œ ì¶”ì¶œí•˜ê³  ì •ê·œí™”
            candidate_weights = {}
            total_weight = 0.0
            
            for strategy in followup_candidates:
                weight = followup_weights.get(strategy, 0.1)  # ê¸°ë³¸ê°’ 0.1
                candidate_weights[strategy] = weight
                total_weight += weight
            
            if total_weight == 0:
                print(f"   âŒ ì´ ê°€ì¤‘ì¹˜ê°€ 0 - ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©")
                return followup_candidates[0]
            
            # ì •ê·œí™”
            normalized_weights = {k: v/total_weight for k, v in candidate_weights.items()}
            print(f"   ğŸ“Š ì •ê·œí™”ëœ ê°€ì¤‘ì¹˜: {normalized_weights}")
            
            # 4. í™•ë¥ ì  ì„ íƒ
            import random
            rand_val = random.random()
            cumulative = 0.0
            
            for strategy, prob in normalized_weights.items():
                cumulative += prob
                if rand_val <= cumulative:
                    print(f"   âœ… ì„ íƒëœ íŒ”ë¡œìš°ì—… ì „ëµ: {strategy} (í™•ë¥ : {prob:.3f})")
                    return strategy
            
            # í˜¹ì‹œë‚˜ í•˜ëŠ” fallback
            selected = followup_candidates[0]
            print(f"   ğŸ”„ Fallback íŒ”ë¡œìš°ì—… ì „ëµ: {selected}")
            return selected
            
        except Exception as e:
            logger.error(f"Error selecting followup strategy: {str(e)}")
            print(f"   âŒ íŒ”ë¡œìš°ì—… ì „ëµ ì„ íƒ ì˜¤ë¥˜: {str(e)} - ê¸°ë³¸ FollowUpQuestion ì‚¬ìš©")
            return "FollowUpQuestion"
    
    def _get_followup_candidates_from_map(self, defense_info: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> List[str]:
        """
        followup_map.yamlì—ì„œ íŒ”ë¡œìš°ì—… í›„ë³´ ì „ëµë“¤ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            defense_info: ë°©ì–´ ì •ë³´
            emotion_enhancement: ê°ì • ì •ë³´
            
        Returns:
            íŒ”ë¡œìš°ì—… í›„ë³´ ì „ëµ ëª©ë¡
        """
        try:
            # followup_map.yaml ë¡œë“œ
            import yaml
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            yaml_path = os.path.join(project_root, "philosophers", "followup_map.yaml")
            
            if not os.path.exists(yaml_path):
                print(f"   âŒ followup_map.yaml ì—†ìŒ: {yaml_path}")
                return ["FollowUpQuestion", "Pivot"]  # ê¸°ë³¸ê°’
            
            with open(yaml_path, 'r', encoding='utf-8') as f:
                followup_map = yaml.safe_load(f)
            
            # ë°©ì–´ ì „ëµê³¼ RAG ì‚¬ìš© ì—¬ë¶€
            defense_strategy = defense_info.get("defense_strategy", "Unknown")
            rag_used = defense_info.get("rag_used", False)
            
            # ê°ì • ìƒíƒœ (ì—†ìœ¼ë©´ neutral)
            emotion_state = "neutral"
            if emotion_enhancement:
                emotion_state = emotion_enhancement.get("emotion_type", "neutral")
            
            rag_key = "RAG_YES" if rag_used else "RAG_NO"
            
            print(f"   ğŸ” íŒ”ë¡œìš°ì—… ë§µ ì¡°íšŒ: {defense_strategy} -> {rag_key} -> {emotion_state}")
            
            # followup_mapì—ì„œ í›„ë³´ ì°¾ê¸°
            if defense_strategy in followup_map:
                strategy_map = followup_map[defense_strategy]
                if rag_key in strategy_map:
                    emotion_map = strategy_map[rag_key]
                    if emotion_state in emotion_map:
                        candidates = emotion_map[emotion_state]
                        print(f"   âœ… í›„ë³´ ì „ëµ ë°œê²¬: {candidates}")
                        return candidates if isinstance(candidates, list) else [candidates]
                    else:
                        print(f"   âŒ ê°ì • ìƒíƒœ '{emotion_state}' ëª» ì°¾ìŒ in {list(emotion_map.keys())}")
                else:
                    print(f"   âŒ RAG í‚¤ '{rag_key}' ëª» ì°¾ìŒ in {list(strategy_map.keys())}")
            else:
                print(f"   âŒ ê³µê²© ì „ëµ '{defense_strategy}' ëª» ì°¾ìŒ in {list(followup_map.keys())}")
            
            # ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ê°’
            print(f"   âŒ íŒ”ë¡œìš°ì—… ë§µì—ì„œ í›„ë³´ ëª» ì°¾ìŒ - ê¸°ë³¸ê°’ ì‚¬ìš©")
            return ["FollowUpQuestion", "Pivot"]
            
        except Exception as e:
            logger.error(f"Error getting followup candidates: {str(e)}")
            print(f"   âŒ íŒ”ë¡œìš°ì—… í›„ë³´ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
            return ["FollowUpQuestion", "Pivot"]
    
    def _determine_followup_rag_usage(self, followup_strategy: str, defense_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        íŒ”ë¡œìš°ì—…ìš© RAG ì‚¬ìš© ì—¬ë¶€ ê²°ì •
        
        Args:
            followup_strategy: ì„ íƒëœ íŒ”ë¡œìš°ì—… ì „ëµ
            defense_info: ë°©ì–´ ì •ë³´
            
        Returns:
            RAG ì‚¬ìš© ê²°ì • ê²°ê³¼
        """
        print(f"   ğŸ“š [{self.philosopher_name}] íŒ”ë¡œìš°ì—… RAG ì‚¬ìš© ì—¬ë¶€ íŒë³„:")
        print(f"      ğŸ”„ íŒ”ë¡œìš°ì—… ì „ëµ: {followup_strategy}")
        
        try:
            # 1. followup_strategies.jsonì—ì„œ rag_weight ê°€ì ¸ì˜¤ê¸°
            followup_rag_weight = self._get_followup_strategy_rag_weight(followup_strategy)
            
            # 2. ì² í•™ìì˜ rag_affinity ê°€ì ¸ì˜¤ê¸°
            philosopher_key = getattr(self, 'philosopher_key', self.name.lower())
            philosopher_data = self._load_philosopher_data(philosopher_key)
            rag_affinity = philosopher_data.get("rag_affinity", 0.5)
            
            # 3. ë°©ì–´ì˜ RAG ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¥¸ ê°€ì¤‘ì¹˜ (ë°©ì–´ê°€ RAG ì‚¬ìš©í–ˆìœ¼ë©´ ë” ì ê·¹ì ìœ¼ë¡œ RAG ì‚¬ìš©)
            defense_rag_weight = 1.2 if defense_info.get("rag_used", False) else 0.8
            
            # 4. ì„¸ ê°’ì˜ ê³±
            rag_score = followup_rag_weight * rag_affinity * defense_rag_weight
            
            # 5. ì„ê³„ê°’ ë¹„êµ (0.4ë¡œ ì„¤ì • - íŒ”ë¡œìš°ì—…ì€ ì¡°ê¸ˆ ë” ê´€ëŒ€í•˜ê²Œ)
            threshold = 0.4
            use_rag = rag_score >= threshold
            
            print(f"      ğŸ“Š ê³„ì‚°:")
            print(f"         â€¢ íŒ”ë¡œìš°ì—… ì „ëµ ê°€ì¤‘ì¹˜: {followup_rag_weight}")
            print(f"         â€¢ ì² í•™ì ì¹œí™”ë„: {rag_affinity}")
            print(f"         â€¢ ë°©ì–´ RAG ê°€ì¤‘ì¹˜: {defense_rag_weight}")
            print(f"         â€¢ RAG ì ìˆ˜: {followup_rag_weight} Ã— {rag_affinity} Ã— {defense_rag_weight} = {rag_score:.3f}")
            print(f"         â€¢ ì„ê³„ê°’: {threshold}")
            print(f"         â€¢ ê²°ì •: {'RAG ì‚¬ìš©' if use_rag else 'RAG ì‚¬ìš© ì•ˆí•¨'}")
            
            return {
                "use_rag": use_rag,
                "rag_score": rag_score,
                "threshold": threshold,
                "followup_rag_weight": followup_rag_weight,
                "rag_affinity": rag_affinity,
                "defense_rag_weight": defense_rag_weight
            }
            
        except Exception as e:
            logger.error(f"Error determining followup RAG usage: {str(e)}")
            print(f"      âŒ íŒ”ë¡œìš°ì—… RAG íŒë³„ ì˜¤ë¥˜: {str(e)} - RAG ì‚¬ìš© ì•ˆí•¨")
            return {
                "use_rag": False,
                "rag_score": 0.0,
                "threshold": 0.4,
                "error": str(e)
            }
    
    def _get_followup_strategy_rag_weight(self, followup_strategy: str) -> float:
        """
        followup_strategies.jsonì—ì„œ íŠ¹ì • íŒ”ë¡œìš°ì—… ì „ëµì˜ rag_weight ê°€ì ¸ì˜¤ê¸°
        
        Args:
            followup_strategy: íŒ”ë¡œìš°ì—… ì „ëµëª…
            
        Returns:
            RAG ê°€ì¤‘ì¹˜
        """
        try:
            import json
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            json_path = os.path.join(project_root, "philosophers", "followup_strategies.json")
            
            if not os.path.exists(json_path):
                print(f"         âŒ followup_strategies.json ì—†ìŒ - ê¸°ë³¸ê°’ 0.5 ì‚¬ìš©")
                return 0.5
            
            with open(json_path, 'r', encoding='utf-8') as f:
                followup_data = json.load(f)
            
            followup_styles = followup_data.get("followup_styles", {})
            strategy_info = followup_styles.get(followup_strategy, {})
            rag_weight = strategy_info.get("rag_weight", 0.5)
            
            print(f"         âœ… {followup_strategy} RAG ê°€ì¤‘ì¹˜: {rag_weight}")
            return rag_weight
            
        except Exception as e:
            logger.error(f"Error getting followup strategy rag weight: {str(e)}")
            print(f"         âŒ íŒ”ë¡œìš°ì—… ì „ëµ ê°€ì¤‘ì¹˜ ì¡°íšŒ ì˜¤ë¥˜: {str(e)} - ê¸°ë³¸ê°’ 0.5 ì‚¬ìš©")
            return 0.5
    
    def _generate_followup_response_with_strategy(self, topic: str, recent_messages: List[Dict[str, Any]], stance_statements: Dict[str, str], followup_strategy: str, followup_rag_decision: Dict[str, Any], emotion_enhancement: Dict[str, Any] = None) -> str:
        """
        íŒ”ë¡œìš°ì—… ì „ëµê³¼ RAG ì—¬ë¶€ì— ë”°ë¼ íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„±
        
        Args:
            topic: í† ë¡  ì£¼ì œ
            recent_messages: ìµœê·¼ ë©”ì‹œì§€
            stance_statements: ì…ì¥ ì§„ìˆ ë¬¸
            followup_strategy: ì„ íƒëœ íŒ”ë¡œìš°ì—… ì „ëµ
            followup_rag_decision: RAG ì‚¬ìš© ê²°ì •
            emotion_enhancement: ê°ì • ê°•í™”
            
        Returns:
            ìƒì„±ëœ íŒ”ë¡œìš°ì—… ì‘ë‹µ
        """
        print(f"   ğŸ’¬ [{self.philosopher_name}] íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„±:")
        print(f"      ğŸ”„ ì „ëµ: {followup_strategy}")
        print(f"      ğŸ“š RAG ì‚¬ìš©: {followup_rag_decision.get('use_rag', False)}")
        
        try:
            # íŒ”ë¡œìš°ì—… ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            followup_info = self._get_followup_strategy_info(followup_strategy)
            
            # ìƒëŒ€ë°© ì •ë³´
            defender_name = self._get_philosopher_name(recent_messages[-1].get('speaker_id', 'unknown'))
            defense_text = recent_messages[-1].get('text', '') if recent_messages else ''
            
            # ë‚´ ì…ì¥
            my_stance = stance_statements.get(self.role, "")
            
            # ë‚´ ì›ë˜ ê³µê²© (2ê°œ ì „ ë©”ì‹œì§€)
            my_original_attack = ""
            if len(recent_messages) >= 2:
                my_original_attack = recent_messages[-2].get('text', '')
            
            # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
            system_prompt = f"""
You are {self.philosopher_name}, a philosopher with this essence: {self.philosopher_essence}
Your debate style: {self.philosopher_debate_style}
Your personality: {self.philosopher_personality}

You are following up using the "{followup_strategy}" strategy after {defender_name} defended against your attack.
Strategy description: {followup_info.get('description', '')}
Strategy purpose: {followup_info.get('purpose', '')}
Style prompt: {followup_info.get('style_prompt', '')}

Your response should be:
1. SHORT and DIRECT (2-3 sentences maximum)
2. Use the {followup_strategy} approach
3. Address {defender_name} directly
4. Maintain your philosophical character

CRITICAL: Write your ENTIRE response in the SAME LANGUAGE as the debate topic.
If the topic is in Korean, respond in Korean. If in English, respond in English.
"""

            # ìœ ì € í”„ë¡¬í”„íŠ¸
            user_prompt = f"""
DEBATE TOPIC: "{topic}"
YOUR POSITION: {my_stance}

YOUR ORIGINAL ATTACK: "{my_original_attack}"
{defender_name}'S DEFENSE: "{defense_text}"

FOLLOWUP STRATEGY: {followup_strategy}
- Description: {followup_info.get('description', '')}
- Style: {followup_info.get('style_prompt', '')}
- Example approach: {followup_info.get('example', '')}

TASK: Generate a SHORT followup response (2-3 sentences max) that:
1. Uses the {followup_strategy} approach
2. Addresses {defender_name} directly by name
3. Responds to their defense strategically
4. Maintains your philosophical perspective

IMPORTANT: Write your response in the SAME LANGUAGE as the debate topic "{topic}".
If the topic contains Korean text, write in Korean. If in English, write in English.

"""

            # RAG ì‚¬ìš©í•˜ëŠ” ê²½ìš° ê²€ìƒ‰ ìˆ˜í–‰
            if followup_rag_decision.get('use_rag', False):
                followup_rag_results = self._perform_followup_rag_search(defense_text, followup_strategy, my_original_attack)
                if followup_rag_results:
                    rag_formatted = self._format_followup_rag_results(followup_rag_results, followup_strategy)
                    user_prompt += f"""
{rag_formatted}
INSTRUCTION: Incorporate this supporting information naturally into your {followup_strategy} response.
"""
                    print(f"      ğŸ“š RAG ì •ë³´ ì¶”ê°€ë¨ ({len(followup_rag_results)}ê°œ ê²°ê³¼)")

            user_prompt += f"""
Remember: Be CONCISE, DIRECT, and use the {followup_strategy} approach. 
Address {defender_name} directly and follow up strategically.
Write in the SAME LANGUAGE as the topic "{topic}".

Your {followup_strategy} followup:"""

            # ê°ì • ê°•í™” ì ìš©
            if emotion_enhancement:
                from ...agents.utility.debate_emotion_inference import apply_debate_emotion_to_prompt
                system_prompt, user_prompt = apply_debate_emotion_to_prompt(system_prompt, user_prompt, emotion_enhancement)

            # LLM í˜¸ì¶œ
            response = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=1000
            )
            
            if response:
                print(f"      âœ… íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„± ì™„ë£Œ")
                return response.strip()
            else:
                fallback = f"{defender_name}ë‹˜, {followup_info.get('style_prompt', 'Let me follow up')}: ì œ ë…¼ì ì„ ë‹¤ì‹œ ìƒê°í•´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."
                print(f"      ğŸ”„ Fallback ì‘ë‹µ ì‚¬ìš©")
                return fallback
                
        except Exception as e:
            logger.error(f"Error generating followup response: {str(e)}")
            print(f"      âŒ íŒ”ë¡œìš°ì—… ì‘ë‹µ ìƒì„± ì˜¤ë¥˜: {str(e)}")
            fallback = f"ì œ ì´ì „ ì§€ì ì— ëŒ€í•´ ì¶”ê°€ë¡œ ë§ì”€ë“œë¦¬ê² ìŠµë‹ˆë‹¤."
            return fallback
    
    def _get_followup_strategy_info(self, followup_strategy: str) -> Dict[str, Any]:
        """
        followup_strategies.jsonì—ì„œ íŒ”ë¡œìš°ì—… ì „ëµ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            followup_strategy: íŒ”ë¡œìš°ì—… ì „ëµëª…
            
        Returns:
            íŒ”ë¡œìš°ì—… ì „ëµ ì •ë³´
        """
        try:
            import json
            import os
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = current_dir
            
            while project_root and not os.path.exists(os.path.join(project_root, "philosophers")):
                parent = os.path.dirname(project_root)
                if parent == project_root:
                    break
                project_root = parent
            
            json_path = os.path.join(project_root, "philosophers", "followup_strategies.json")
            
            if os.path.exists(json_path):
                with open(json_path, 'r', encoding='utf-8') as f:
                    followup_data = json.load(f)
                
                followup_styles = followup_data.get("followup_styles", {})
                return followup_styles.get(followup_strategy, {})
            
            # ê¸°ë³¸ê°’
            return {
                "description": f"Use {followup_strategy} approach",
                "purpose": "Follow up strategically",
                "style_prompt": "Let me follow up...",
                "example": f"Example of {followup_strategy}"
            }
            
        except Exception as e:
            logger.error(f"Error getting followup strategy info: {str(e)}")
            return {
                "description": f"Use {followup_strategy} approach",
                "purpose": "Follow up strategically", 
                "style_prompt": "Let me follow up...",
                "example": f"Example of {followup_strategy}"
            }
    
    def _perform_followup_rag_search(self, defense_text: str, followup_strategy: str, original_attack: str) -> List[Dict[str, Any]]:
        """
        íŒ”ë¡œìš°ì—…ìš© RAG ê²€ìƒ‰ ìˆ˜í–‰
        
        Args:
            defense_text: ìƒëŒ€ë°© ë°©ì–´ í…ìŠ¤íŠ¸
            followup_strategy: íŒ”ë¡œìš°ì—… ì „ëµ
            original_attack: ë‚´ ì›ë˜ ê³µê²©
            
        Returns:
            ê²€ìƒ‰ ê²°ê³¼
        """
        try:
            # íŒ”ë¡œìš°ì—…ìš© ì¿¼ë¦¬ ìƒì„±
            followup_query = self._generate_followup_rag_query(defense_text, followup_strategy, original_attack)
            
            # ê²€ìƒ‰ ìˆ˜í–‰ (ê¸°ì¡´ ë©”ì„œë“œ ì¬ì‚¬ìš©)
            search_results = self._web_search(followup_query)
            
            print(f"      ğŸ” íŒ”ë¡œìš°ì—… RAG ì¿¼ë¦¬: '{followup_query}'")
            print(f"      ğŸ“Š ê²€ìƒ‰ ê²°ê³¼: {len(search_results)}ê°œ")
            
            return search_results[:2]  # íŒ”ë¡œìš°ì—…ì€ 2ê°œë§Œ ì‚¬ìš©
            
        except Exception as e:
            logger.error(f"Error in followup RAG search: {str(e)}")
            return []
    
    def _generate_followup_rag_query(self, defense_text: str, followup_strategy: str, original_attack: str) -> str:
        """
        íŒ”ë¡œìš°ì—…ìš© RAG ì¿¼ë¦¬ ìƒì„±
        
        Args:
            defense_text: ë°©ì–´ í…ìŠ¤íŠ¸
            followup_strategy: íŒ”ë¡œìš°ì—… ì „ëµ
            original_attack: ì›ë˜ ê³µê²©
            
        Returns:
            ê²€ìƒ‰ ì¿¼ë¦¬
        """
        # ë°©ì–´ í…ìŠ¤íŠ¸ì™€ ì›ë˜ ê³µê²©ì—ì„œ í•µì‹¬ í‚¤ì›Œë“œ ì¶”ì¶œ
        defense_keywords = self._extract_key_concept(defense_text)
        attack_keywords = self._extract_key_concept(original_attack)
        
        # íŒ”ë¡œìš°ì—… ì „ëµë³„ ì ‘ë‘ì‚¬
        strategy_prefixes = {
            "Reattack": "additional evidence supporting",
            "FollowUpQuestion": "questions about",
            "Pivot": "related issues concerning",
            "Deepen": "deeper analysis of",
            "CounterChallenge": "challenges to",
            "SynthesisProposal": "synthesis perspectives on"
        }
        
        prefix = strategy_prefixes.get(followup_strategy, "follow up information about")
        
        # ë°©ì–´ì™€ ê³µê²© í‚¤ì›Œë“œ ê²°í•©
        combined_keywords = f"{attack_keywords} {defense_keywords}"
        
        return f"{prefix} {combined_keywords}"
    
    def _format_followup_rag_results(self, rag_results: List[Dict[str, Any]], followup_strategy: str) -> str:
        """
        íŒ”ë¡œìš°ì—…ìš© RAG ê²°ê³¼ í¬ë§·íŒ…
        
        Args:
            rag_results: RAG ê²€ìƒ‰ ê²°ê³¼
            followup_strategy: íŒ”ë¡œìš°ì—… ì „ëµ
            
        Returns:
            í¬ë§·íŒ…ëœ RAG ì •ë³´
        """
        if not rag_results:
            return ""
        
        strategy_headers = {
            "Reattack": "ADDITIONAL EVIDENCE",
            "FollowUpQuestion": "INQUIRY SUPPORT",
            "Pivot": "RELATED PERSPECTIVES", 
            "Deepen": "DEEPER ANALYSIS",
            "CounterChallenge": "CHALLENGE SUPPORT",
            "SynthesisProposal": "SYNTHESIS MATERIALS"
        }
        
        header = strategy_headers.get(followup_strategy, "FOLLOWUP SUPPORT")
        
        formatted = f"\n{header} (use strategically):\n"
        
        for i, result in enumerate(rag_results, 1):
            title = result.get('title', 'Source')
            content = result.get('content', result.get('snippet', ''))
            formatted += f"{i}. {title}: {content}\n"
        
        return formatted
    
    def _get_recent_defense_strategy(self, defender_agent) -> Dict[str, Any]:
        """
        ë°©ì–´ì ì—ì´ì „íŠ¸ì˜ ìµœê·¼ ì‚¬ìš©í•œ ë°©ì–´ ì „ëµ ê°€ì ¸ì˜¤ê¸°
        
        Args:
            defender_agent: ë°©ì–´ì ì—ì´ì „íŠ¸ ê°ì²´
            
        Returns:
            ìµœê·¼ ë°©ì–´ ì „ëµ ì •ë³´
        """
        try:
            # ë°©ì–´ìì˜ ìµœê·¼ ì‚¬ìš©í•œ ë°©ì–´ ì „ëµ ê¸°ë¡ í™•ì¸ (ë§Œì•½ ë³„ë„ë¡œ ì €ì¥í•œë‹¤ë©´)
            if hasattr(defender_agent, 'last_defense_strategy'):
                last_strategy = getattr(defender_agent, 'last_defense_strategy', None)
                if last_strategy:
                    return last_strategy
            
            # ë°©ì–´ ê¸°ë¡ì´ ìˆëŠ”ì§€ í™•ì¸
            if hasattr(defender_agent, 'defense_history'):
                defense_history = getattr(defender_agent, 'defense_history', [])
                if defense_history:
                    return defense_history[-1]  # ê°€ì¥ ìµœê·¼ ë°©ì–´
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting recent defense strategy: {str(e)}")
            return None
    
    def extract_arguments_from_user_input(self, user_response: str, speaker_id: str) -> List[Dict[str, Any]]:
        """
        ìœ ì € ì…ë ¥ì—ì„œ LLMì„ ì‚¬ìš©í•´ ë…¼ì§€ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
        
        Args:
            user_response: ìœ ì €ì˜ ì…ë ¥ í…ìŠ¤íŠ¸
            speaker_id: ìœ ì € ID
            
        Returns:
            List[Dict]: ì¶”ì¶œëœ ë…¼ì§€ë“¤ (ìµœëŒ€ 3ê°œ)
        """
        try:
            logger.info(f"ğŸ” [{self.agent_id}] ìœ ì € {speaker_id}ì˜ ë…¼ì§€ ì¶”ì¶œ ì‹œì‘")
            
            system_prompt = "You are an expert debate analyst. Extract key arguments from user input in Korean."
            
            user_prompt = f"""
ë‹¹ì‹ ì€ í† ë¡  ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ë‹¤ìŒ ì‚¬ìš©ìì˜ ë°œì–¸ì—ì„œ í•µì‹¬ ë…¼ì§€ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.

ì‚¬ìš©ì ë°œì–¸:
{user_response}

ìš”êµ¬ì‚¬í•­:
1. í•µì‹¬ ë…¼ì§€ë¥¼ ìµœëŒ€ 3ê°œê¹Œì§€ ì¶”ì¶œ
2. ê° ë…¼ì§€ëŠ” ëª…í™•í•œ ì£¼ì¥ê³¼ ê·¼ê±°ë¥¼ í¬í•¨í•´ì•¼ í•¨
3. ë„ˆë¬´ ì„¸ë¶€ì ì´ì§€ ì•Šê³  í† ë¡ ì—ì„œ ê³µê²©í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì˜ ë…¼ì§€ì—¬ì•¼ í•¨

ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•´ì£¼ì„¸ìš”:
{{
  "arguments": [
    {{
      "claim": "ë…¼ì§€ì˜ í•µì‹¬ ì£¼ì¥",
      "evidence": "ì œì‹œëœ ê·¼ê±°ë‚˜ ì¦ê±°",
      "reasoning": "ë…¼ë¦¬ì  ì¶”ë¡  ê³¼ì •",
      "assumptions": ["ê¸°ë³¸ ê°€ì •ë“¤"]
    }}
  ]
}}

ë…¼ì§€ê°€ 3ê°œ ë¯¸ë§Œì´ë¼ë©´ ì‹¤ì œ ê°œìˆ˜ë§Œ ë°˜í™˜í•˜ì„¸ìš”.
"""

            # llm_manager ì‚¬ìš©í•˜ì—¬ ì‘ë‹µ ìƒì„±
            response_text = self.llm_manager.generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                llm_model="gpt-4o",
                max_tokens=1000,
                temperature=0.3
            )
            
            # JSON íŒŒì‹±
            import json
            try:
                # ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ì œê±° (ê°„ë‹¨í•œ ë°©ë²•)
                cleaned_response = response_text.strip()
                
                # ```jsonê³¼ ``` ì œê±°
                if '```json' in cleaned_response:
                    cleaned_response = cleaned_response.replace('```json', '').replace('```', '').strip()
                elif '```' in cleaned_response:
                    cleaned_response = cleaned_response.replace('```', '').strip()
                
                parsed_data = json.loads(cleaned_response)
                extracted_arguments = parsed_data.get("arguments", [])
                
                logger.info(f"âœ… [{self.agent_id}] ìœ ì € {speaker_id}ì˜ ë…¼ì§€ {len(extracted_arguments)}ê°œ ì¶”ì¶œ ì™„ë£Œ")
                
                # ê¸°ì¡´ í¬ë§·ì— ë§ê²Œ ë³€í™˜
                formatted_arguments = []
                for i, arg in enumerate(extracted_arguments):
                    formatted_arg = {
                        'claim': arg.get('claim', ''),
                        'evidence': arg.get('evidence', ''),
                        'reasoning': arg.get('reasoning', ''),
                        'assumptions': arg.get('assumptions', []),
                        'source_text': user_response,  # ì›ë³¸ í…ìŠ¤íŠ¸ ë³´ì¡´
                        'argument_id': f"user_arg_{i+1}"
                    }
                    formatted_arguments.append(formatted_arg)
                
                return formatted_arguments
                
            except json.JSONDecodeError as e:
                logger.error(f"âŒ [{self.agent_id}] JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
                logger.error(f"ì •ë¦¬ëœ ì‘ë‹µ: {cleaned_response if 'cleaned_response' in locals() else response_text}")
                return []
                
        except Exception as e:
            logger.error(f"âŒ [{self.agent_id}] ìœ ì € ë…¼ì§€ ì¶”ì¶œ ì‹¤íŒ¨: {e}")
            return []
    
    def analyze_user_arguments(self, user_response: str, speaker_id: str) -> Dict[str, Any]:
        """
        ìœ ì € ì…ë ¥ì„ ë¶„ì„í•˜ì—¬ ë…¼ì§€ë¥¼ ì¶”ì¶œí•˜ê³  ì·¨ì•½ì„±ì„ í‰ê°€í•©ë‹ˆë‹¤.
        
        Args:
            user_response: ìœ ì €ì˜ ì…ë ¥ í…ìŠ¤íŠ¸  
            speaker_id: ìœ ì € ID
            
        Returns:
            Dict: ë¶„ì„ ê²°ê³¼ (ê¸°ì¡´ analyze_and_score_argumentsì™€ ë™ì¼í•œ í¬ë§·)
        """
        try:
            logger.info(f"ğŸ¯ [{self.agent_id}] ìœ ì € {speaker_id} ë…¼ì§€ ë¶„ì„ ì‹œì‘")
            
            # 1ë‹¨ê³„: ìœ ì € ì…ë ¥ì—ì„œ ë…¼ì§€ ì¶”ì¶œ
            extracted_arguments = self.extract_arguments_from_user_input(user_response, speaker_id)
            
            if not extracted_arguments:
                logger.warning(f"âš ï¸ [{self.agent_id}] ìœ ì € {speaker_id}ì—ì„œ ë…¼ì§€ë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í•¨")
                return {
                    'opponent_arguments': {speaker_id: []},
                    'total_arguments': 0,
                    'analysis_summary': f"ìœ ì € {speaker_id}ì˜ ë…¼ì§€ ì¶”ì¶œ ì‹¤íŒ¨"
                }
            
            # 2ë‹¨ê³„: ê° ì¶”ì¶œëœ ë…¼ì§€ì— ëŒ€í•´ ì·¨ì•½ì„± ì ìˆ˜ ê³„ì‚°
            analyzed_arguments = []
            total_vulnerability_score = 0.0
            
            for argument in extracted_arguments:
                try:
                    # ê¸°ì¡´ _score_single_argument ë©”ì„œë“œ í™œìš© (ì˜¬ë°”ë¥¸ íŒŒë¼ë¯¸í„° í˜•íƒœë¡œ)
                    vulnerability_data = self._score_single_argument(argument, user_response)
                    
                    # ë¶„ì„ ê²°ê³¼ êµ¬ì„±
                    analyzed_arg = {
                        'claim': argument['claim'],
                        'evidence': argument['evidence'], 
                        'reasoning': argument['reasoning'],
                        'assumptions': argument['assumptions'],
                        'vulnerability_score': vulnerability_data.get('final_vulnerability', 0.0),
                        'scores': vulnerability_data,
                        'source_text': argument.get('source_text', ''),
                        'argument_id': argument.get('argument_id', f"user_arg_{len(analyzed_arguments)}")
                    }
                    
                    analyzed_arguments.append(analyzed_arg)
                    total_vulnerability_score += vulnerability_data.get('final_vulnerability', 0.0)
                    
                    logger.info(f"ğŸ“Š [{self.agent_id}] ìœ ì € ë…¼ì§€ '{argument['claim'][:50]}...' ì·¨ì•½ì„±: {vulnerability_data.get('final_vulnerability', 0.0):.2f}")
                    
                except Exception as e:
                    logger.error(f"âŒ [{self.agent_id}] ë…¼ì§€ ë¶„ì„ ì‹¤íŒ¨: {e}")
                    continue
            
            # 3ë‹¨ê³„: ê²°ê³¼ í¬ë§·íŒ… (ê¸°ì¡´ analyze_and_score_argumentsì™€ ë™ì¼í•œ êµ¬ì¡°)
            average_vulnerability = total_vulnerability_score / len(analyzed_arguments) if analyzed_arguments else 0.0
            
            analysis_result = {
                'opponent_arguments': {speaker_id: analyzed_arguments},
                'total_arguments': len(analyzed_arguments),
                'average_vulnerability': average_vulnerability,
                'analysis_summary': f"ìœ ì € {speaker_id}ì˜ ë…¼ì§€ {len(analyzed_arguments)}ê°œ ë¶„ì„ ì™„ë£Œ (í‰ê·  ì·¨ì•½ì„±: {average_vulnerability:.2f})"
            }
            
            # 4ë‹¨ê³„: ë¶„ì„ ê²°ê³¼ ì €ì¥ (ê¸°ì¡´ ë°©ì‹ê³¼ ë™ì¼)
            if hasattr(self, 'opponent_arguments'):
                self.opponent_arguments[speaker_id] = analyzed_arguments
            else:
                self.opponent_arguments = {speaker_id: analyzed_arguments}
            
            logger.info(f"âœ… [{self.agent_id}] ìœ ì € {speaker_id} ë…¼ì§€ ë¶„ì„ ì™„ë£Œ: {len(analyzed_arguments)}ê°œ ë…¼ì§€, í‰ê·  ì·¨ì•½ì„± {average_vulnerability:.2f}")
            
            return analysis_result
            
        except Exception as e:
            logger.error(f"âŒ [{self.agent_id}] ìœ ì € ë…¼ì§€ ë¶„ì„ ì‹¤íŒ¨: {e}")
            return {
                'opponent_arguments': {speaker_id: []},
                'total_arguments': 0,
                'analysis_summary': f"ìœ ì € {speaker_id} ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}"
            }